# 2-1 TypeScript的编译机制

# 一 概览

TypeScript 编译器源文件位于src/compiler目录下

分为以下几个关键部分：

* Scanner扫描器（scanner.ts）
* Parser解析器（parser.ts）
* Binder绑定器（binder.ts）
* Checker检查器（checker.ts）
* Emitter发射器（emitter.ts）

## 1.1 处理概览

* 符号（Symbol）是TypeScript语义系统的主要构造块。符号是绑定的结果。符号将AST中的声明节点与相同实体声明相连。
```js
SourceCode(源码) ~~ 扫描器 ~~> Token流 ~~ 解析器 ~~> AST（抽象生成树）~~ 绑定器 ~~> Symbols（符号）
```

* 符号和AST是检查器用来验证源代码语义的
```js
AST + 符号 ~~ 检查器 ~~> 类型验证
```

* 输出JS：
```js
AST + 检查器 ~~ 发射器 ~~> JS代码
```

## 1.2 文件：Utilities
core.ts：TypeScript编译器使用的核心工具集，重要的有：
* let ObjectAllocator: ObjectAllocator是一个定义为全局单例的变量。提供以下定义：
 * getNodeConstructor(节点会在解析器/AST中介绍)
 * getSymbolConstructor(符号会在绑定器中介绍)
 * getTypeConstructor(类型会在检查器中介绍)
 * getSignatureConstructor(签名是索引，调用和构造签名)

## 1.3 文件：关键数据结构
types.ts：包含整个编译器中使用的关键数据结构和接口，这里列出一些关键部分：
 * SyntaxKind AST节点类型通过SyntaxKind枚举进行识别；
 * TypeChecker类型检查器提供此接口；
 * CompilerHost用于程序(Program)和系统之间的交互
 * Node AST节点

## 1.4 文件：系统
 system.ts：TypeScript编译器与操作系统的所有交互均通过System接口进行。接口及其实现（WScript和Node）均定义在system中，你可以将其视为操作环境。

# 二 程序
 > 程序定义在program.ts中，编译上下文在TypeScript编译器中被视为一个Program，它包含SourceFile和编译选项。
 
## 2.1 CompilerHost的使用
 CompilerHost是与操作环境进行交互的
 Program - 使用 -> CompilerHost - 使用 -> System

 用CompilerHost作中间层的原因是可以让接口对Program的需求进行细粒度的调整，而无需考虑操作环境的需求。（例如：Program无需关心System的fileExists函数）
 对System而言还有其他的使用者（比如测试）

## 2.2 SourceFile
 程序有个API，勇于获取SourceFile：getSourceFiles(); SourceFile[]，得到的每个元素均是一课抽象语法树的根节点（称做SourceFile）

# 三 抽象语法树

## 3.1 Node节点

 节点是抽象语法树（AST)de基本构造块，语法上，通常Node表示非末端（non-terminals）节点。但是，有些末端节点，如：标识符和字面量也会保留在树中。

 AST节点文档由两个关键部分构成。一是节点的SyntaxKind枚举，用于标识AST中的类型。二是其接口，即实例化AST时节点提供的API。

 这里是interface Node的一些关键成员：

 * TextRange标识该节点在源文件中的起止位置。
 * parent?: Node 当前节点（在AST中）的父节点

 Node还有一些其他的成员，标志（flags）和修饰符（modifiers）等。你可以在源码中搜索interface Node来查看，而上面提到对节点的遍历是非常重要的。

## 3.2 SourceFile
 * SyntaxKind.SourceFile
 * interface SourceFile

 每个SourceFile都是一棵AST的顶级节点，它们包含在Program中。

## 3.3 AST技巧：访问子节点
 有个工具函数ts.forEachChild可以用来访问AST任一节点的所有子节点。

 下面是简化的代码片段，用于演示如何工作：

 ```js
 export function forEachChild<T>(node: Node, cbNode: (node: Node) => T, cbNodeArray?: (Nodes:Node[]) => T): T {
   if (!node) {
     return;
   }
   switch (node.kind) {
     case SyntaxKind.BinaryExpression:
       return visitNode(cbNode, (<BinaryExpression>node).left) ||
         visitNode(cbNode, (<BinaryExpression>node).operatorToken) ||
         visitNode(cbNode, (<BinaryExpression>node).right);
     case SyntaxKind.IfStatement:
       return visitNode(cbNode, (<IfStatement>node).expression) ||
         visitNode(cbNode, (<IfStatement>node).thenStatement) ||
         visitNode(cbNode, (<IfStatement>node).elseStatement);
     // .... 更多
   }
 } 
 ```

 该函数主要检查node.kind并据此判断node的接口，然后在其子节点上调用cbNode。但是，要注意该函数不会为所有子节点调用visitNode（例如：SyntaxKind.SemicolonToken）。想获得某AST节点的所有子节点，只要调用该节点的成员函数.getChildren。

 如下函数会打印AST节点详细信息：

 ```js
 function printAllChildren(node: ts.Node, depth = 0) {
   console.log(new Array(depth + 1).join('----'), ts.syntaxKindToName(node.kind), node.pos, node.end);
   depth++;
   node.getChildren().forEach(c => printAllChildren(c, depth));
 }
 ```

 我们进一步讨论解析器时会看到该函数的使用示例。

## 3.4 AST技巧：SyntaxKind枚举
 SyntaxKind被定义为一个常量枚举，如下所示：

 ```js
 export const enum SyntaxKind {
   Unknown,
   EndOfFileToken,
   SingleLineCommentTrivia,
   // ...更多
 }
 ```

 这是个常量枚举，方便内联（例如：ts.SyntaxKind.EndOfFileToken会变为1），这样在使用AST时就不会有处理引用的额外开销。但编译时需要使用--preserveConstEnums编译标志，以便枚举在运行时仍可用。JavaScript中你也可以根据需要使用ts.SyntaxKind.EndOfFileToken。另外，可以用以下函数，将枚举成员转化为可读的字符串：

 ```js
 export function syntaxKindToName(kind: ts.SyntaxKind) {
   return (<any>ts).SyntaxKind[kind];
 }
 ```

## 3.5 AST杂项

 杂项(Trivia)是指源文本中对正常理解代码不太重要的部分，例如：空白，注释，冲突标记。（为了保持轻量）杂项不会存储在AST中。但是可以视需要使用一些ts.* API来获取。

 展示这些API前，你需要理解以下内容：

## 杂项的所有权
 通常：
 * token拥有它后面同一行到下一个token之前的所有杂项；
 * 该行之后的注释都与下个token相关；

 对于文件中的前导（leading）和结束（ending）注释：
 * 源文件中的第一个token拥有所有开始的杂项；
 * 而文件最后的一些列杂项则附加到文件结束符上，该token长度为0；

## 杂项API
 注释在多数基本使用中，都是让人关注的杂项。节点的注释可以通过以下函数获取：

 | 函数 | 描述 |
 | ---- | ---- |
 | ts.getLeadingCommentRanges | 给定源文本及其位置，返回给定位置后第一个换行符到token本身之间的注释范围（可能需要结合ts.Node.getFullStart使用） |
 | ts.getTrailingCommentRanges | 给定源文本及其位置，返回给定位置后第一个换行符之前的注释范围（可能需要结合ts.Node.getEnd使用） |

 假设下面是某个源文件的一部分：

 ```js
 debugger; /*hello*/
 //bye
 /*hi*/    function
 ```

 对function而言，getLeadingCommentRanges仅返回最后的两个注释//bye和/*hi*/。另外，而在debugger语句结束位置调用getTrailingCommentRanges会得到注释/*hello*/。

## Token Start和Full Start位置

 节点有所谓的"token start"和"full start"位置。
 * Token Start：比较自然的版本，即文件中一个token的文本开始的位置。
 * Full Start：是指扫描器从上一个重要token开始扫描的位置。

 AST节点有getStart和getFullStart API用于获取以上两种位置，还是这个例子：

 ```js
 debugger; /*hello*/
 //bye
 /*hi*/    function
 ```

 对function而言，token start即function的位置，而full start是 /*hello*/的位置。要注意，full start甚至会包含前一节点拥有的杂项。

# 四、扫描器

TypeScript扫描器的源码均位于scanner.ts。在内部，由解析器控制扫描器将源码转化为抽象语法树（AST）。期望结果如下：
```js
SourceCode ~~ 扫描器 ~~> Token流 ~~ 解析器 ~~> AST
```

## 4.1 解析器对扫描器的使用

为避免重复创建扫描器造成的开销，parser.ts中创建了一个扫描器的单例。解析器根据需要使用initializeState函数准备该扫描器。

下面是解析器中的实际代码的简化版，你可以运行它演示以上概念

code/compiler/scanner/runScanner.ts

```js
import * as ts from 'ntypescript';

// 单例扫描器
const scanner = ts.createScanner(ts.ScriptTarget.Latest, /* 忽略杂项 */ true);

// 此函数与初始化使用的`initializeState`函数相似
function initializeState(text: string) {
  scanner.setText(text);
  scanner.setOnError(message: ts.DiagnosticMessage, lenght: number) => {
    console.error(message);
  };
  scanner.setScriptTarget(ts.ScriptTarget.ES5);
  scanner.setLanguageVariant(ts.LanguageVariant.Standard);
}

// 使用示例
initializeState(
  ` 
  var foo = 123;
  `.trim();
);

// 开始扫描
var token = scanner.scan();
while(token != ts.SyntaxKind.EndOfFileToken) {
  console.log(ts.formatSyntaxKind(token));
  token = scanner.scan();
}
```

该段代码输出以下内容：

```js
VarKeyword
Identifier
FirstAssignment
FirstLiteralToken
SemicolonToken
```

## 4.2 扫描器状态
调用scan后，扫描器更新其局部状态（扫描位置，当前token详情等）。扫描器提供了一组工具函数获取当前扫描器状态。下例中，我们创建一个扫描器并用它识别token以及token在代码中的位置。
code/compiler/scanner/runScannerWithPosition.ts

```js
// 使用示例
initializeState(
  `
  var foo = 123;
  `.trim();
);

// 开始扫描
var token = scanner.scan();
while(token != ts.SynntaxKind.EndOfFileToken) {
  let currentToken = ts.formatSyntaxKind(token);
  let tokenStart = scanner.getStartPos();
  token = scanner.scan();
  let tokenEnd = scanner.getStartPos();
  console.log(currentToken, tokenStart, tokenEnd);
}
```

该代码输出以下内容：

```js
VarKeyword 0 3
Identifier 3 7
FirstAssignment 7 9
FirstLiteralToken 9 13
SemicolonToken 13 14
```

## 4.3 独立扫描器
即便TypeScript解析器有单例扫描器，你仍可以使用createScanner创建独立的扫描器，然后可以用setText/setTextPos随意扫描文件的不同位置。

# 五、解析器

TypeScript解析器代码均位于parser.ts中。在内部，由解析器控制扫描器将源码转化为AST。其期望结果如下：

```js
源码 ~~ 扫描器 ~~> Token流 ~~ 解析器 ~~> AST
```

解析器实现原理是单例模式（其原因类似扫描器，如果能重新初始化就不重新构建）。实际实现成namespace Parser，包含解析器的各种状态变量和单例扫描器（const scanner）。该扫描器由解析器函数管理。

## 5.1 程序对解析器的使用

解析器由程序间接驱动（通过之前提到过的CompilerHost）。基本上，简化的调用栈如下所示：

```js
程序 -> 
  CompilerHost.getSourceFile =>
    (全局函数 parser.ts).createSourceFile ->
      Parser.parseSourceFile
```

parseSourceFile不仅准备好解析器的状态，还调用initializeState准备好扫描器的状态。然后使用parseSourceFileWorker继续解析源代码。

## 5.2 使用示例

深入解析器的内部之前，这里有个使用TypeScript解析器的示例，（使用ts.createSourceFile）获取一个源文件的AST并打印它。

code/compiler/parser/runParser.ts

```js
import * as ts from 'ntypescript';
function printAllChildren(node: ts.Node, depth = 0) {
  console.log(new Array(depth + 1).join('----'), ts.formatSyntaxKind(node.kind), node.pos, node.end);
  depth++;
  node.getChildren().forEach(c => printAllChildren(c, depth));
}

var sourceCode = `
var foo = 123;
`.trim();

var sourceFile = ts.createSourceFile('foo.ts', sourceCode, ts.ScriptTarget.ES5, true);
printAllChildren(sourceFile);
```

该段代码会打印以下内容：

```js
SourceFile 0 14
---- SyntaxList 0 14
-------- VariableStatement 0 14
------------ VariableDeclarationList 0 13
---------------- VarKeyword 0 3
---------------- SyntaxList 3 13
-------------------- VariableDeclaration 3 13
------------------------ Identifier 3 7
------------------------ FirstAssignment 7 9
------------------------ FirstLiteralToken 9 13
------------ SemicolonToken 13 14
---- EndOfFileToken 14 14
```

如果把头向左倾，这个看起来像棵（右侧）树。

## 5.3 解析器函数

如前所述，parseSourceFile设置初始状态并将工作交给parseSourceFileWorker函数。

* parseSourceFileWorker

该函数先创建一个SourceFile AST节点，然后从parseStatements函数开始解析源代码。一旦返回结果，就用额外信息（例如nodeCount， identifierCount等）完善SourceFile节点。

* parseStatements
是最重要的parseXXX系列函数之一。它根据扫描器返回当前token来切换（调用相应的parseXXX函数），例如：如果当前token是一个SemicolonToken(分号标记)，就会调用paserEmptyStatement为空语句创建一个AST节点。

## 5.4 节点创建
解析器有一系列parseXXX函数用来创建相应类型为XXX的节点，通常在相应类型的节点出现时被（其他解析器函数）调用。该过程的典型示例是解析空语句（例如;;;;;;）时要用的parseEmptyStatement()函数。下面是其全部代码：

```js
function parseEmptyStatement(): Statement {
  let node = <Statement>createNode(SyntaxKind.EmptyStatement);
  parseExpected(SyntaxKind.SemicolonToken);
  return finishNode(node);
}
```

它展示了3个关键函数createNode，parseExpected和finishNode。

* createNode
解析器函数function createNode(kind: SyntaxKind, pos?: number): Node负责创建节点，设置传入的SyntaxKind（语法类别），和初始位置（默认使用当前扫描器状态提供的位置信息）。

* parseExpected
解析器的parseExpected函数function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage): boolean会检查解析器状态中的当前token是否与指定的SyntaxKind匹配。
如果不匹配，则会向传入的diagnosticMessage(诊断消息)报告，未传入则创建某种通用形式xxxexpected。该函数内部用parseErrorAtPosition函数（使用扫描位置）提供良好的错误报告。

* finishNode
解析器的finishNode函数 function finishNode<T extends Node>(node: T, end?: number): T设置节点的end位置，并添加一些有用的信息，例如上下文标志（parserContextFlags）以及解析该节点前出现的错误（如果有错误的话，就不能在增量解析中重用此AST节点）。
