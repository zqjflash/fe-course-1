# 1-7 设计模式

## 一、创建型模式
 * 抽象工厂：创建一系列相关的对象，无需指定其具体类
 ![6-1-7-1.png](/assets/6-1-7-1.png)

  * 使用场景：许多框架和程序库会将它作为扩展和自定义其标准组件的一种方式。
  * 识别方法：可以通过方法来识别该模式-其会返回一个工厂对象，工厂将被用于创建特定的子组件。

 * 代码示例如下：

 ```js
 // 抽象工厂接口声明了一组返回不同抽象产品的方法。这些产品称为“家庭”，并且与高级主题或概念相关。一个家庭的产品通常能够彼此协作。一个产品家族可能有多个变体，但是一个变体的产品与另一个变体的产品不兼容。
 interface AbstractFactory {
   createProductA(): AbstractProductA;
   createProductB(): AbstractProductB;
 }

 // 具体工厂生产的产品家族属于单个变体。工厂保证最终产品兼容。注意混凝土工厂方法的签名返回一个抽象产品；在该方法内部实例化混凝土产品时。
 class ConcreteFactory1 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA1();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB1();
   }
 }

 // 每个混凝土工厂都有相应的产品变型
 class ConcreteFactory2 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA2();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB2();
   }
 }

 // 产品系列的每个不同产品都应具有基本接口。产品的所有变体都必须实现此接口。
 interface AbstractProductA {
   usefulFunctionA(): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductA1 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A1.';
   }
 }

 class ConcreteProductA2 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A2.';
   }
 }

 // 这是另一种产品的基本接口。所有产品都可以相互交互，但是只有相同具体变体的产品之间才可能进行正确的交互。
 interface AbstractProductB {
   // 产品B能够做自己的事
   usefulFunctionB(): string;
   // 但它也可以与ProductA合作。抽象工厂确保它创建的所有产品都是相同的变体，因此是兼容的。
   anotherUsefulFunctionB(collaborator: AbstractProductA): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductB1 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B1.';
   }
   // 变体产品B1仅可与变体产品A1一起正常使用。不过，它接受AbstractProductA的任何实例作为参数
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B1 collaborating with the (${result})`;
   }
 }

 class ConcreteProductB2 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B2.';
   }
   // 变体产品B2仅能与变体产品A2一起正常使用。不过，它接受AbstractProductA的任何实例作为参数。
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B2 collaborating with the (${result})`;
   }
 }

 // 客户端代码仅通过抽象类型（AbstractFactory和AbstractProduct）与工厂和产品一起使用。这使您可以将任何工厂或产品子类传递给客户端代码，而不会破坏它。
 function clientCode(factory: AbstractFactory) {
   const productA = factory.createProductA();
   const productB = factory.createProductB();
   console.log(productB.usefulFunctionB());
   console.log(productB.anotherUsefulFunctionB(productA));
 }

 // 客户端代码可以与任何具体的工厂类一起使用
 console.log('Client: Testing client code with the first factory type...');
 clientCode(new ConcreteFactory1());
 console.log('');

 console.log('Client: Testing the same client code with the second factory type...');
 clientCode(new ConcreteFactory2());
 ```

 * 生成器: 使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。
 ![6-1-7-2.png](/assets/6-1-7-2.png)
  * 使用场景：当你需要创建一个可能有许多配置选项的对象时，该模式会特别有用。
  * 识别方法：通过类来识别，它拥有一个构建方法和多个配置结果对象的方法。生成器方法通常支持方法链。
  * 代码示例如下：
  ```js
  // Builder接口指定用于创建Product对象的不同部分的方法
  interface Builder {
    producePartA(): void;
    producePartB(): void;
    producePartC(): void;
  }

  // ConcreteBuilder类遵循Builder界面并提供构建步骤的特定实现。您的程序可能具有多种的构建器变体，实现方式有所不同。
  class ConcreteBuilder1 implements Builder {
    private product: Product1;
    // 新的构建器实例应包含一个空白产品对象，该对象用于进一步的组装
    constructor() {
      this.reset();
    }
    public reset(): void {
      this.product = new Product1();
    }
    // 所有生产步骤均适用于同一产品实例
    public producePartA(): void {
      this.product.parts.push('PartA1');
    }
    public producePartB(): void {
      this.product.parts.push('PartB1');
    }
    public producePartC(): void {
      this.product.parts.push('PartC1');
    }
    // 混凝土建造者应该提供自己的方法来检索结果。这是因为各种类型的构建器可能会创建完全不同的产品，这些产品不遵循相同的界面。因此，不能在基本的Builder接口中声明此类方法（至少使用静态类型的编程语言）。通常，在将最终结果返回给客户之后，构建器实例可以准备开始生产另一种产品。这就是为什么通常的做法是在getProduct方法主体的末尾调用reset方法。但是，此行为不是强制性的，并且您可以让您的构建器在处置之前的结果之前，等待来自客户代码的显式reset调用
    public getProduct(): Product1 {
      const result = this.product;
      this.reset();
      return result;
    }
  }

  // 仅当您的产品非常复杂并且需要大量配置时，才使用Builder模式。与其他创作模式不同，不同的混凝土建造者可以生产不相关的产品。换句话说，各种构建器的结果可能并不总是遵循相同的界面。
  class Product1 {
    public parts: string[] = [];
    public listParts(): void {
      console.log(`Product parts: ${this.parts.join(', ')}\n`);
    }
  }

  // 主管仅负责按特定顺序执行构建步骤。根据*特定的订单或配置生产产品时，这很有帮助。严格来说，Director类是可选的，因为客户端可以直接控制构建器。
  class Director {
    private builder: Builder;
    // Director与客户端代码传递的任何构建器实例一起使用。这样，客户代码可以更改新组装产品的最终类型
    public setBuilder(builder: builder): void {
      this.builder = builder;
    }
    // Director可以使用相同的构建步骤构造多个产品变体
    public buildMinimalViableProduct(): void {
      this.builder.producePartA();
    }
    public buildFullFeatureProduct(): void {
      this.builder.producePartA();
      this.builder.producePartB();
      this.builder.producePartC();
    }
  }

  // 客户代码创建一个构建器对象，将其传递给控制器​​，然后启动构建过程。最终结果是从构建器对象中检索的
  function clientCode(director: Director) {
    const builder = new ConcreteBuilder1();
    director.setBuilder(builder);

    console.log('Standard basic product:');
    director.buildMinimalViableProduct();
    builder.getProduct().listParts();

    console.log('Standard full featured product:');
    director.buildFullFeaturedProduct();
    builder.getProduct().listParts();

    // 记住，Builder模式可以在没有Director类的情况下使用
    console.log('Custom product:');
    builder.producePartA();
    builder.producePartC();
    builder.getProduct().listParts();
  }
  const director = new Director();
  clientCode(director);
  ```

  执行结果：
  ```js
  Standard basic product:
  Product parts: PartA1

  Standard full featured product:
  Product parts: PartA1, PartB1, PartC1

  Custom product:
  Product parts: PartA1, PartC1
  ```

 * 工厂方法：在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。
 ![6-1-7-3.png](/assets/6-1-7-3.png)

 ```js
 // Creator类声明了工厂方法，该方法应返回Product类的对象。创建者的子类通常提供此方法的实现
 abstract class Creator {
   // 请注意，创建者可能还会提供工厂方法的一些默认实现
   public abstract factoryMethod(): Product;
   // 另请注意，尽管它有名字，但创建者的主要责任是不创建产品。通常，它包含一些依赖于Product对象的核心业务逻辑，这些逻辑是由factory方法返回的。子类可以通过覆盖工厂方法并从中返回不同类型的产品来间接更改该业务逻辑
   public someOperation(): string {
     // 调用工厂方法创建一个Product对象
     const product = this.factoryMethod();
     // 现在，使用product
     return `Creator: The same creator's code has just worked with ${product.operation()}`;
   }
 }

 // 具体的创建者会覆盖工厂方法以更改结果产品的类型
 class ConcreteCreator1 extends Creator {
   // 请注意，即使具体对象的方法实际上是从方法返回的，该方法的签名仍然使用抽象对象类型。这样，创建者可以保持独立于具体产品类的状态
   public factoryMethod(): Product {
     return new ConcreteProduct1();
   }
 }

 class ConcreteCreator2 extends Creator {
   public factoryMethod(): Product {
     return new ConcreteProduct2();
   }
 }

 // 产品接口声明所有具体产品必须实施的操作
 interface Product {
   operation(): string;
 }

 // 具体产品提供产品接口的各种实现
 class ConcreteProduct1 implements Product {
   public operation(): string {
     return '{Result of the ConcreteProduct1}';
   }
 }

 class ConcreteProduct2 implements Product {
    public operation(): string {
      return '{Result of the ConcreteProduct2}';
    }
 }

 // 客户端代码尽管是通过其基本接口，但仍与具体创建者的实例一起工作。只要客户端继续通过基本接口与创建者合作，就可以将其传递给任何创建者的子类
 function clientCode(creator: Creator) {
    // ...
    console.log('Client: I\'m not aware of the creator\'s class, but it still works.');
    console.log(creator.someOperation());
    // ...
 }

 // 应用程序根据配置或环境选择创建者的类型
 console.log('App: Launched with the ConcreteCreator1.');
 clientCode(new ConcreteCreator1());
 console.log('');

 console.log('App: Launched with the ConcreteCreator2.');
 clientCode(new ConcreteCreator2());
 ```

## 二、结构型模式
 * 适配器：让接口不兼容的对象能够相互合作
 ![6-1-7-4.png](/assets/6-1-7-4.png)

 ```js
 // 目标定义客户端代码使用的特定于域的接口
 class Target {
   public request(): string {
     return 'Target: The default target\'s behavior.';
   }
 }
 // Adaptee包含一些有用的行为，但是其接口与现有的客户端代码不兼容。在客户端代码可以使用它之前，Adaptee需要进行一些调整
 class Adaptee {
   public specificRequest(): string {
     return '.eetpadA eht fo roivaheb laicepS';
   }
 }

 // 适配器使Adaptee的接口与Target的接口兼容
 class Adapter extends Target {
   private adaptee: Adaptee;
   constructor(adaptee: Adaptee) {
     super();
     this.adaptee = adaptee;
   }
   public request(): string {
     const result = this.adaptee.specificRequest().split('').reverse().join('');
     return `Adapter: (TRANSLATED) ${result}`;
   }
 }

 // 客户端代码支持遵循Target接口的所有类
 function clientCode(target: Target) {
   console.log(target.request());
 }

 console.log('Client: I can work just fine with the Target objects:');
 const target = new Target();
 clientCode(target);
 console.log('');

 const adaptee = new Adaptee();
 console.log('Client: The Adaptee class has a weird interface. See, I don\'t understand it:');
 console.log(`Adaptee: ${adaptee.specificRequest()}`);

 console.log('');
 console.log('Client: But I can work with it via the Adapter:');
 const adapter = new Adapter(adaptee);
 clientCode(adapter);
 ```

## 三、行为模式
 * 命令
 * 迭代器
 * 观察者
 * 策略

