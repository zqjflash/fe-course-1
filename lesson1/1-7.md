# 1-7 设计模式

## 一、创建型模式
 * 抽象工厂：创建一系列相关的对象，无需指定其具体类
  * 使用场景：许多框架和程序库会将它作为扩展和自定义其标准组件的一种方式。
  * 识别方法：可以通过方法来识别该模式-其会返回一个工厂对象，工厂将被用于创建特定的子组件。

 * 代码示例如下：

 ```js
 // 抽象工厂接口声明了一组返回不同抽象产品的方法。这些产品称为“家庭”，并且与高级主题或概念相关。一个家庭的产品通常能够彼此协作。一个产品家族可能有多个变体，但是一个变体的产品与另一个变体的产品不兼容。
 interface AbstractFactory {
   createProductA(): AbstractProductA;
   createProductB(): AbstractProductB;
 }

 // 具体工厂生产的产品家族属于单个变体。工厂保证最终产品兼容。注意混凝土工厂方法的签名返回一个抽象产品；在该方法内部实例化混凝土产品时。
 class ConcreteFactory1 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA1();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB1();
   }
 }

 // 每个混凝土工厂都有相应的产品变型
 class ConcreteFactory2 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA2();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB2();
   }
 }

 // 产品系列的每个不同产品都应具有基本接口。产品的所有变体都必须实现此接口。
 interface AbstractProductA {
   usefulFunctionA(): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductA1 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A1.';
   }
 }

 class ConcreteProductA2 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A2.';
   }
 }

 // 这是另一种产品的基本接口。所有产品都可以相互交互，但是只有相同具体变体的产品之间才可能进行正确的交互。
 interface AbstractProductB {
   // 产品B能够做自己的事
   usefulFunctionB(): string;
   // 但它也可以与ProductA合作。抽象工厂确保它创建的所有产品都是相同的变体，因此是兼容的。
   anotherUsefulFunctionB(collaborator: AbstractProductA): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductB1 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B1.';
   }
   // 变体产品B1仅可与变体产品A1一起正常使用。不过，它接受AbstractProductA的任何实例作为参数
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B1 collaborating with the (${result})`;
   }
 }

 class ConcreteProductB2 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B2.';
   }
   // 变体产品B2仅能与变体产品A2一起正常使用。不过，它接受AbstractProductA的任何实例作为参数。
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B2 collaborating with the (${result})`;
   }
 }

 // 客户端代码仅通过抽象类型（AbstractFactory和AbstractProduct）与工厂和产品一起使用。这使您可以将任何工厂或产品子类传递给客户端代码，而不会破坏它。
 function clientCode(factory: AbstractFactory) {
   const productA = factory.createProductA();
   const productB = factory.createProductB();
   console.log(productB.usefulFunctionB());
   console.log(productB.anotherUsefulFunctionB(productA));
 }

 // 客户端代码可以与任何具体的工厂类一起使用
 console.log('Client: Testing client code with the first factory type...');
 clientCode(new ConcreteFactory1());
 console.log('');

 console.log('Client: Testing the same client code with the second factory type...');
 clientCode(new ConcreteFactory2());
 ```

 * 生成器: 创建型设计模式，使你能够分步骤创建复杂对象
  * 使用场景：当你需要创建一个可能有许多配置选项的对象时，该模式会特别有用。
  * 识别方法：通过类来识别，它拥有一个构建方法和多个配置结果对象的方法。生成器方法通常支持方法链。
  * 代码示例如下：
  ```js
  // Builder接口指定用于创建Product对象的不同部分的方法
  interface Builder {
    producePartA(): void;
    producePartB(): void;
    producePartC(): void;
  }

  // ConcreteBuilder类遵循Builder界面并提供构建步骤的特定实现。您的程序可能具有多种的构建器变体，实现方式有所不同。
  class ConcreteBuilder1 implements Builder {
    private product: Product1;
    // 新的构建器实例应包含一个空白产品对象，该对象用于进一步的组装
    constructor() {
      this.reset();
    }
    public reset(): void {
      this.product = new Product1();
    }
    // 所有生产步骤均适用于同一产品实例
    public producePartA(): void {
      this.product.parts.push('PartA1');
    }
    public producePartB(): void {
      this.product.parts.push('PartB1');
    }
    public producePartC(): void {
      this.product.parts.push('PartC1');
    }
    // 混凝土建造者应该提供自己的方法来检索结果。这是因为各种类型的构建器可能会创建完全不同的产品，这些产品不遵循相同的界面。因此，不能在基本的Builder接口中声明此类方法（至少使用静态类型的编程语言）。通常，在将最终结果返回给客户之后，构建器实例可以准备开始生产另一种产品。这就是为什么通常的做法是在getProduct方法主体的末尾调用reset方法。但是，此行为不是强制性的，并且您可以让您的构建器在处置之前的结果之前，等待来自客户代码的显式reset调用
    public getProduct(): Product1 {
      const result = this.product;
      this.reset();
      return result;
    }
  }

  // 仅当您的产品非常复杂并且需要大量配置时，才使用Builder模式。与其他创作模式不同，不同的混凝土建造者可以生产不相关的产品。换句话说，各种构建器的结果可能并不总是遵循相同的界面。
  class Product1 {
    public parts: string[] = [];
    public listParts(): void {
      console.log(`Product parts: ${this.parts.join(', ')}\n`);
    }
  }

  // 主管仅负责按特定顺序执行构建步骤。根据*特定的订单或配置生产产品时，这很有帮助。严格来说，Director类是可选的，因为客户端可以直接控制构建器。
  class Director {
    private builder: Builder;
    // Director与客户端代码传递的任何构建器实例一起使用。这样，客户代码可以更改新组装产品的最终类型
    public setBuilder(builder: builder): void {
      this.builder = builder;
    }
    // Director可以使用相同的构建步骤构造多个产品变体
    public buildMinimalViableProduct(): void {
      this.builder.producePartA();
    }
    public buildFullFeatureProduct(): void {
      this.builder.producePartA();
      this.builder.producePartB();
      this.builder.producePartC();
    }
  }

  // 客户代码创建一个构建器对象，将其传递给控制器​​，然后启动构建过程。最终结果是从构建器对象中检索的
  function clientCode(director: Director) {
    const builder = new ConcreteBuilder1();
    director.setBuilder(builder);

    console.log('Standard basic product:');
    director.buildMinimalViableProduct();
    builder.getProduct().listParts();

    console.log('Standard full featured product:');
    director.buildFullFeaturedProduct();
    builder.getProduct().listParts();

    // 记住，Builder模式可以在没有Director类的情况下使用
    console.log('Custom product:');
    builder.producePartA();
    builder.producePartC();
    builder.getProduct().listParts();
  }
  const director = new Director();
  clientCode(director);
  ```

  执行结果：
  ```js
  Standard basic product:
  Product parts: PartA1

  Standard full featured product:
  Product parts: PartA1, PartB1, PartC1

  Custom product:
  Product parts: PartA1, PartC1
  ```

 * 工厂方法

## 二、结构型模式
 * 适配器

## 三、行为模式
 * 命令
 * 迭代器
 * 观察者
 * 策略

