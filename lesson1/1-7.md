# 1-7 设计模式

## 一、创建型模式
 * 抽象工厂：创建一系列相关的对象，无需指定其具体类，许多框架和程序库会将它作为扩展和自定义其标准组件的一种方式。

 ```js
 // 抽象工厂接口声明了一组返回不同抽象产品的方法。这些产品称为“家庭”，并且与高级主题或概念相关。一个家庭的产品通常能够彼此协作。一个产品家族可能有多个变体，但是一个变体的产品与另一个变体的产品不兼容。
 interface AbstractFactory {
   createProductA(): AbstractProductA;
   createProductB(): AbstractProductB;
 }

 // 具体工厂生产的产品家族属于单个变体。工厂保证最终产品兼容。注意混凝土工厂方法的签名返回一个抽象产品；在该方法内部实例化混凝土产品时。
 class ConcreteFactory1 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA1();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB1();
   }
 }

 // 每个混凝土工厂都有相应的产品变型
 class ConcreteFactory2 implements AbstractFactory {
   public createProductA(): AbstractProductA {
     return new ConcreteProductA2();
   }
   public createProductB(): AbstractProductB {
     return new ConcreteProductB2();
   }
 }

 // 产品系列的每个不同产品都应具有基本接口。产品的所有变体都必须实现此接口。
 interface AbstractProductA {
   usefulFunctionA(): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductA1 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A1.';
   }
 }

 class ConcreteProductA2 implements AbstractProductA {
   public usefulFunctionA(): string {
     return 'The result of the product A2.';
   }
 }

 // 这是另一种产品的基本接口。所有产品都可以相互交互，但是只有相同具体变体的产品之间才可能进行正确的交互。
 interface AbstractProductB {
   // 产品B能够做自己的事
   usefulFunctionB(): string;
   // 但它也可以与ProductA合作。抽象工厂确保它创建的所有产品都是相同的变体，因此是兼容的。
   anotherUsefulFunctionB(collaborator: AbstractProductA): string;
 }

 // 这些混凝土产品是由相应的混凝土工厂创建的
 class ConcreteProductB1 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B1.';
   }
   // 变体产品B1仅可与变体产品A1一起正常使用。不过，它接受AbstractProductA的任何实例作为参数
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B1 collaborating with the (${result})`;
   }
 }

 class ConcreteProductB2 implements AbstractProductB {
   public usefulFunctionB(): string {
     return 'The result of the product B2.';
   }
   // 变体产品B2仅能与变体产品A2一起正常使用。不过，它接受AbstractProductA的任何实例作为参数。
   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
     const result = collaborator.usefulFunctionA();
     return `The result of the B2 collaborating with the (${result})`;
   }
 }

 // 客户端代码仅通过抽象类型（AbstractFactory和AbstractProduct）与工厂和产品一起使用。这使您可以将任何工厂或产品子类传递给客户端代码，而不会破坏它。
 function clientCode(factory: AbstractFactory) {
   const productA = factory.createProductA();
   const productB = factory.createProductB();
   console.log(productB.usefulFunctionB());
   console.log(productB.anotherUsefulFunctionB(productA));
 }

 // 客户端代码可以与任何具体的工厂类一起使用
 console.log('Client: Testing client code with the first factory type...');
 clientCode(new ConcreteFactory1());
 console.log('');

 console.log('Client: Testing the same client code with the second factory type...');
 clientCode(new ConcreteFactory2());
 ```

 * 生成器
 * 工厂方法

## 二、结构型模式
 * 适配器

## 三、行为模式
 * 命令
 * 迭代器
 * 观察者
 * 策略

