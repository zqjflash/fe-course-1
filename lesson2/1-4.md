# 1-4 哈希算法

## 哈希算法解决三数之和

给你一个包含n个整数的数组nums，判断nums中是否存在三个元素a, b, c，使得a + b + c = 0？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

给定数组nums = [-1, 0, 1, 2, -1, -4],
满足要求的三元组集合为：[[-1, 0, 1], [-1, -1, 2]];

## 思路

注意[0, 0, 0, 0]这组数据

## 哈希解法

两层for循环就可以确定a和b的数值了，可以使用哈希法来确定0-(a+b)是否在数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。

把符合条件的三元组放进vector中，然后在去去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。

去重的过程不好处理，有很多小细节，如果在面试中很难想到位。

时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。

大家可以尝试使用哈希法写一写，就知道其困难的程度了。

## 双指针

其实这道题目使用哈希法并不十分合适，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。

而且使用哈希法在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，但是程序的时间执行时间依然比较长。

接下来我来介绍另一个解法：双指针法，这道题目使用双指针法要比哈希法高效一些，那么来讲解一下具体实现的思路。

动画效果如下：

![2-1-4-0](/assets/2-1-4-0.png)

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下表0的地方开始，同时定一个下表left定义在i+1的位置上，定义下表right在数组结尾的位置上。

依然还是在数组中找到abc使得a + b + c = 0，我们这里相当于a=nums[i] b = nums[left] c = nums[right].

接下来如何移动left和right呢，如果nums[i] + nums[left] + nums[right] > 0就说明此时三数之和大了，因为数组是排序后了，所以right下表就应该向左移动，这样才能让三数之和小一些。

如果nums[i] + nums[left] + nums[right] < 0说明此时三数之和小了，left就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：O(n^2)

整体代码：

```js
const threeSum = (nums) => {
  const len = nums.length;
  if (len < 3) {
    return [];
  }
  nums.sort((a, b) => a - b);
  const res = [];
  for (let i = 0; i < len - 2; i++) {
    if (nums[i] > 0) {
      break;
    }
    // a去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let l = i + 1;
    let r = len - 1;
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r];
      if (sum < 0) {
        l++;
        continue;
      }
      if (sum > 0) {
        r--;
        continue;
      }
      res.push([nums[i], nums[l], nums[r]]);
      // b c 去重
      while(l < r && nums[l] === nums[++l]);
      while(l < r && nums[r] === nums[--r]);
    }
  }
  return res;
}
```
