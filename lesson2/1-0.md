# 1-0 递归

## 一、递归算法的时间复杂度

> 通过一道简单的面试题，模拟面试的场景，来带大家逐步分析递归算法的时间复杂度，最后找出最优解，来看看同样是递归，怎么就写成了O(n)的代码

* 面试题：求x的n次方

```js
int function1(int x, int n) {
    int result = 1; // 注意，任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

时间复杂度为O(n)，此时面试官会说，有没有效率更好的算法。考虑一下递归算法

```js
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

递归算法的时间复杂度本质上是要看：递归的次数*每次递归中的操作次数。上面代码每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度是一个常数项O(1)，所以这份代码的时间复杂度是n*1=O(n)。

这个时间复杂度没有达到面试官的预期，接着写出如下的递归算法的代码：

```js
int function3(int x, int n) {
    if (n===0) {
        return 1;
    }
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2) * x;
    }
}
```

把递归抽象出一颗满二叉树，为了方便表示，选择n为偶数16，如图：

![2-1-0](/assets/2-1-0.png)

当前这颗二叉树就是求x的n次方，n为16的情况，
这棵树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点

熟悉二叉树话应该知道如何求满二叉树节点数量，这颗满二叉树的节点数量就是2^3 + 2^2 + 2^1 + 2^0 = 15，可以发现：这其实是等比数列的求和公式，这个结论在二叉树相关的面试题里也经常出现

![2-1-1](/assets/2-1-1.png)

时间复杂度忽略掉常数项-1之后，这个递归算法的时间复杂度依然是O(n)。

进一步优化递归代码：

```js
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2); // 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```

依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n/2 ，所以这里我们一共调用了log以2为底n的对数次。

每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)。

此时大家最后写出了这样的代码并且将时间复杂度分析的非常清晰，相信面试官是比较满意的。

* 总结

求x的n次方，来逐步分析递归算法的时间复杂度，注意不要一看到递归就想到了O(logn)！

同样使用递归，有的同学可以写出O(logn)的代码，有的同学还可以写出O(n)的代码。

对于function3 这样的递归实现，很容易让人感觉这是O(logn)的时间复杂度，其实这是O(n)的算法！

```js
int function3(int x, int n) {
    if (n == 0) {
        return 1;
    }
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

## 二、递归求斐波那契数列的性能分析

```js
int fibonacci(int i) {
    if (i <= 0) {
        return 0;
    }
    if (i == 1) {
        return 1;
    }
    return fibonacci(i-1) + fibonacci(i-2);
}
```

对于递归算法来说，代码一般都比较简短，从算法逻辑上看，所用的存储空间也非常少，但运行时需要内存可不见得会少。

### 2.1 斐波那契的递归算法的时间复杂度是多少呢?

递归算法的时间复杂度本质上是要看：递归的次数 * 每次递归的时间复杂度

可以看出上面的代码每次递归都是O(1)的操作。再来看递归了多少次，这里将i为5作为输入的递归过程 抽象成一颗递归树，如图：

![2-1-2](/assets/2-1-2.png)

从图中，可以看出f(5)是由f(4)和f(3)相加而来，那么f(4)是由f(3)和f(2)相加而来 以此类推。

在这颗二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？
我们之前也有说到，一颗深度（按根节点深度为1）为k的二叉树最多可以有2^k-1个节点。所以该递归算法的时间复杂度为O(2^n)，这个复杂度是非常大的，随着n的增大，耗时是指数上升的。

罪魁祸首就是这里的两次递归，导致了时间复杂度以指数上升。

```js
return fibonacci(i-1) + fibonacci(i-2);
```

优化一下这个递归算法，主要是减少递归的调用次数。

```js
// 版本二
int fibonacci(int first, int second, int n) {
    if (n <= 0) {
        return 0;
    }
    if (n < 3) {
        return 1;
    }
    else if (n == 3) {
        return first + second;
    }
    else {
        return fibonacci(second, first + second, n - 1);
    }
}
```

这里相当于用first和second来记录当前相加的两个数值，此时就不用两次递归了。
因为每次递归的时候n-1，即只是递归了n次，所以时间复杂度是O(n)。
同理递归的深度依然是n，每次递归所需的空间也是常数，所以空间复杂度依然是O(n)。

代码（版本二）的复杂度如下：
* 时间复杂度：O(n)
* 空间复杂度：O(n)

### 2.2 空间复杂度分析

递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

* 为什么要求递归的深度呢？

因为每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。

此时可以分析这段递归的空间复杂度，从代码中可以看出每次递归所需要的空间大小都是一样的，所以每次递归中需要的空间是一个常量，并不是随着n的变化而变化，每次递归的空间复杂度就是O(1)。

在看递归的深度是多少呢？如图所示：

![2-1-3](/assets/2-1.png)

递归第n个斐波那契数的话，递归调用栈的深度就是n。
那么每次递归的空间复杂度是O(1)，调用栈深度为n，所以这段递归代码的空间复杂度就是O(n)。

```js
int fibonacci(int i) {
    if (i <= 0) {
        return 0;
    }
    if (i == 1) {
        return 1;
    }
    return fibonacci(i-1) + fibonacci(i-2);
}
```

最后对各种求斐波那契数列方法的性能做一下分析，如题：

| 求斐波那契数 | 时间复杂度 | 空间复杂度 |
| ---- | ---- | ---- |
| 非递归 | O(n) | O(1) |
| 递归算法 | O(2^n) | O(n) |
| 优化递归算法 | O(n) | O(n) |

可以看出，求斐波那契数的时候，使用递归算法并不一定是在性能上最优的，但递归确实简化的代码层面的复杂度。

### 2.3 二分法（递归实现）的性能分析

分析一段二分查找的递归实现：

```js
int binary_search(int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x) {
            return mid;
        }
        if (arr[mid] > x) {
            return binary_search(arr, l, mid - 1, x);
        }
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```

二分查找的时间复杂度是O(logn)，那么递归二分查找的空间复杂度是多少？
我们依然看每次递归的空间复杂度和递归的深度

每次递归的空间复杂度可以看出主要就是参数里传入的这个arr数组，但需要注意的是在C/C++中函数传递数组参数，不是整个数组拷贝一份传入函数而是传入的数组首元素的地址。

也就是说每一层递归都是公用一块数组地址空间的，所以每次递归的时间复杂度是常数即O(1)。

再来看递归的深度，二分查找的递归深度是logn，递归深度就是调用栈的长度，那么这段代码的空间复杂度为1*logn=O(logn)。
大家要注意自己所用的语言在传递函数参数的时，是拷贝整个数值还是拷贝地址，如果是拷贝整个数值那么该二分法的空间复杂度就是O(nlogn)。

### 2.4 总结
本章我们详细分析了递归实现的求斐波那契和二分法的空间复杂度，同时也对时间复杂度做了分析。

特别是两种递归实现的求斐波那契数列，其时间复杂度截然不同，另外也验证了时间复杂度为O(2^n)是非常耗时的。

