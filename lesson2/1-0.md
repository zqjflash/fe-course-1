# 1-0 递归

## 一、递归算法的时间复杂度

> 通过一道简单的面试题，模拟面试的场景，来带大家逐步分析递归算法的时间复杂度，最后找出最优解，来看看同样是递归，怎么就写成了O(n)的代码

* 面试题：求x的n次方

```js
int function1(int x, int n) {
    int result = 1; // 注意，任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

时间复杂度为O(n)，此时面试官会说，有没有效率更好的算法。考虑一下递归算法

```js
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

递归算法的时间复杂度本质上是要看：递归的次数*每次递归中的操作次数。上面代码每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度是一个常数项O(1)，所以这份代码的时间复杂度是n*1=O(n)。

这个时间复杂度没有达到面试官的预期，接着写出如下的递归算法的代码：

```js
int function3(int x, int n) {
    if (n===0) {
        return 1;
    }
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2) * x;
    }
}
```

把递归抽象出一颗满二叉树，为了方便表示，选择n为偶数16，如图：

![2-1-0](/assets/2-1-0.png)

当前这颗二叉树就是求x的n次方，n为16的情况，
这棵树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点

熟悉二叉树话应该知道如何求满二叉树节点数量，这颗满二叉树的节点数量就是2^3 + 2^2 + 2^1 + 2^0 = 15，可以发现：这其实是等比数列的求和公式，这个结论在二叉树相关的面试题里也经常出现

![2-1-1](/assets/2-1-1.png)

时间复杂度忽略掉常数项-1之后，这个递归算法的时间复杂度依然是O(n)。

进一步优化递归代码：

```js
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2); // 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```

依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n/2 ，所以这里我们一共调用了log以2为底n的对数次。

每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)。

此时大家最后写出了这样的代码并且将时间复杂度分析的非常清晰，相信面试官是比较满意的。

* 总结

求x的n次方，来逐步分析递归算法的时间复杂度，注意不要一看到递归就想到了O(logn)！

同样使用递归，有的同学可以写出O(logn)的代码，有的同学还可以写出O(n)的代码。

对于function3 这样的递归实现，很容易让人感觉这是O(logn)的时间复杂度，其实这是O(n)的算法！

```js
int function3(int x, int n) {
    if (n == 0) {
        return 1;
    }
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

