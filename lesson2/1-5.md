# 1-5 贪心算法

## 贪心算法理论基础篇

## 基础篇

* 分发饼干
* K次取反后最大化的数组和
* 柠檬水找零

## 高级篇
* 序列问题
 * 摆动序列
 * 单调递增的数字

* 贪心解决股票问题
 * 买卖股票的最佳时机！
 * 买卖股票的最佳时机含手续费

* 两个维度权衡问题
 * 分发糖果
 * 根据身高重建队列

* 有点难度
 * 区间问题
  * 跳跃游戏
  * 跳跃游戏2
  * 用最少数量的箭引爆气球
  * 无重叠区间
  * 划分字母区间
  * 合并区间
* 最大子序和
* 加油站
* 监控二叉树

## 什么是贪心

贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

## 贪心的套路（什么时候用贪心）

贪心算法并没有固定的套路，唯一的难点就是如何通过局部最优，推出整体最优。
如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？
需要手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

最好用的策略就是举反例，如果想不到反例，那么就试一试贪心。
一般数学证明有如下两种方法：
* 数学归纳法
* 反证法

## 贪心一般解题步骤
* 将问题分解为若干个子问题；
* 找出适合的贪心策略；
* 求解每一个子问题的最优解；
* 将局部最优解堆叠成全局最优解

## 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸s[j]。如果s[j] >= g[i]，我们可以将这个饼干j分配给孩子i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例1：输入g = [1, 2, 3], s = [1, 1]输出：1
解释：你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值为1的孩子满足。所以你应该输出1.

示例2：输入：g=[1,2],s=[1,2,3] 输出2
解释：你有两个孩子和三块小饼干，2个孩子的胃口值分别是1，2，你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.

提示：
* 1<= g.length <= 3 * 10^4
* 0 <= s.length <= 3 * 10^4
* 1 <= g[i], s[j] <= 2^31 - 1

## 思路
为了满足更多的小孩，就不要造成饼干尺寸的浪费。
大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。
然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

如图：

![2-1-5-0](/assets/2-1-5-0.png)
这个例子可以看出饼干9 只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例

// 时间复杂度：O(nlogn)
// 空间复杂度：O(1)
class Solution {
public:
  int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int index = s.size() - 1; // 饼干数组的下表
    int result = 0;
    for (int i = g.size() - 1; i >= 0; i--) {
      if (index >= 0 && s[index] >= g[i]) {
        result++;
        index--;
      }
    }
    return result;
  }
}

从代码中可以看出用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。

## 也可以换一个思路，小饼干先喂饱小胃口

代码如下：

```js
const findContentChildren = (g, s) => {
  g = g.sort((a, b) => a - b);
  s = s.sort((a, b) => a - b);
  let result = 0;
  let index = s.length - 1;
  for (let i = g.length - 1; i >= 0; i--) {
    if (index >= 0 && s[index] >= g[i]) {
      result++;
      index--;
    }
  }
  return result;
}
```

## 总结
想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心。