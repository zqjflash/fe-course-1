# 1-5 贪心算法

## 贪心算法理论基础篇

## 基础篇

* 分发饼干
* K次取反后最大化的数组和
* 柠檬水找零

## 高级篇
* 序列问题
 * 摆动序列
 * 单调递增的数字

* 贪心解决股票问题
 * 买卖股票的最佳时机！
 * 买卖股票的最佳时机含手续费

* 两个维度权衡问题
 * 分发糖果
 * 根据身高重建队列

* 有点难度
 * 区间问题
  * 跳跃游戏
  * 跳跃游戏2
  * 用最少数量的箭引爆气球
  * 无重叠区间
  * 划分字母区间
  * 合并区间
* 最大子序和
* 加油站
* 监控二叉树

## 什么是贪心

贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

## 贪心的套路（什么时候用贪心）

贪心算法并没有固定的套路，唯一的难点就是如何通过局部最优，推出整体最优。
如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？
需要手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

最好用的策略就是举反例，如果想不到反例，那么就试一试贪心。
一般数学证明有如下两种方法：
* 数学归纳法
* 反证法

## 贪心一般解题步骤
* 将问题分解为若干个子问题；
* 找出适合的贪心策略；
* 求解每一个子问题的最优解；
* 将局部最优解堆叠成全局最优解

## 一、 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸s[j]。如果s[j] >= g[i]，我们可以将这个饼干j分配给孩子i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例1：输入g = [1, 2, 3], s = [1, 1]输出：1
解释：你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值为1的孩子满足。所以你应该输出1.

示例2：输入：g=[1,2],s=[1,2,3] 输出2
解释：你有两个孩子和三块小饼干，2个孩子的胃口值分别是1，2，你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.

提示：
* 1<= g.length <= 3 * 10^4
* 0 <= s.length <= 3 * 10^4
* 1 <= g[i], s[j] <= 2^31 - 1

## 思路
为了满足更多的小孩，就不要造成饼干尺寸的浪费。
大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。
然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

如图：

![2-1-5-0](/assets/2-1-5-0.png)
这个例子可以看出饼干9 只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例

// 时间复杂度：O(nlogn)
// 空间复杂度：O(1)
class Solution {
public:
  int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int index = s.size() - 1; // 饼干数组的下表
    int result = 0;
    for (int i = g.size() - 1; i >= 0; i--) {
      if (index >= 0 && s[index] >= g[i]) {
        result++;
        index--;
      }
    }
    return result;
  }
}

从代码中可以看出用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。

## 也可以换一个思路，小饼干先喂饱小胃口

代码如下：

```js
const findContentChildren = (g, s) => {
  g = g.sort((a, b) => a - b);
  s = s.sort((a, b) => a - b);
  let result = 0;
  let index = s.length - 1;
  for (let i = g.length - 1; i >= 0; i--) {
    if (index >= 0 && s[index] >= g[i]) {
      result++;
      index--;
    }
  }
  return result;
}
```

## 总结
想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心。

## 二、 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如，[1, 7, 4, 9, 2, 5]是一个摆动序列，因为差值(6, -3, 5, -7, 3)是正负交替出现的。相反，[1, 4, 7, 2, 5]和[1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为0.

给定一个整数序列，返回作为摆动序列的最长子序列的长度。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例1：输入[1, 7, 4, 9, 2, 5]，输出6 解释：整个序列均为摆动序列

示例2：输入：[1, 17, 5, 10, 13, 15, 10, 5, 16, 8] 输出7 解释：这个序列包含几个长度为7摆动序列，其中一个可为[1, 17, 10, 13, 10, 16, 8]

示例3：输入[1, 2, 3, 4, 5, 6, 7, 8, 9] 输出：2

## 思路
要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

这要求最大摆动序列又可以修改数组，如何修改？
来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？
用示例2来具体，如图所示：

![2-1-5-1](/assets/2-1-5-1.png)

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

局部最优推出全局最优，并举不出反例，那么试试贪心算法！（方便表述，以下说的峰值都是指局部峰值）

实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）

这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点。

本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。

所以可以针对序列[2, 5]，可以假设为[2, 2, 5]，这样它就有坡度了，即preDiff = 0，如图：

![2-1-5-2](/assets/2-1-5-2.png)

针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff > 0 && preDiff <= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）

时间复杂度O(n)，空间复杂度O(1)

```js
const wiggleMaxLength = (nums) => {
  if(nums.length <= 1) {
    return nums.length;
  }
  let result = 1;
  let preDiff = 0;
  let curDiff = 0;
  for (let i = 0; i <= nums.length; i++) {
    curDiff = nums[i + 1] - nums[i];
    if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
      result++;
      preDiff = curDiff;
    }
  }
  return result;
}
```

## 三、最大子序和

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例：输入[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出6 解释：连续子数组[4, -1, 2, 1]的和最大，为6.

### 3.1 贪心解法

* 贪心贪的是哪里呢？

如果-2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素"连续和"只会越来越小。

全局最优：选取最大“连续和”

局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

从代码角度上来讲：遍历nums，从头开始用count累计，如果count一旦加上来nums[i]变为负数，那么就应该从nums[i+1]开始从0累计count了，因为已经变为负数的count，只会拖累总和。

这相当于是暴力解法中的不断调整最大子序和区间的起始位置。

那有同学问了，区间终止位置不用调整么？如何才能得到最大“连续和”呢？

区间的终止位置，其实就是如果count取到最大值了，及时记录下来了，例如如下代码：

```js
if (count > result) {
  result = count;
}
```

这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）。

如动画所示：

![2-1-5-3](/assets/2-1-5-3.gif)

红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。

时间复杂度：O(n)，空间复杂度：O(1)

```js
const maxSubArray = (nums) => {
  let result = -Infinity;
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    count += nums[i];
    if (count > result) {
      result = count;
    }
    if (count < 0) {
      count = 0;
    }
  }
  return result;
}
```

## 四、买卖股票的最佳时机

给定一个数组，它的第i个元素是一支给定股票第i天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出手掉之前的股票）。

示例1：输入[7, 1, 5, 3, 6, 4] 输出：7
解释：在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5 - 1 = 4。随后，在第4天（股票价格=3）的时候买入，在第5天（股票价格=6）的时候卖出，这笔交易所能获得利润 = 6 - 3 = 3。

示例2：输入[1, 2, 3, 4, 5] 输出：4
解释：在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出，这笔交易所能获得利润=5-1 = 4.注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例3：输入[7, 6, 4, 3, 1]输出0
解释：在这种情况下，没有交易完成，所以最大利润为0。

提示：
* 1 <= prices.length <= 3 * 10 ^ 4
* 0 <= prices[i] <= 10 ^ 4

### 思路

本题首先要清楚两点：

* 只有一只股票！
* 当前只有买股票或者买股票的操作；
想获得利润至少要两天为一个交易单元。


### 贪心算法
我们只会想，选一个低的买入，在选个高的卖，在选一个低的买入...循环反复。

如果想到其实最终利润是可以分解的，那么本题就很容易了！

如果分解呢？

假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。
相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

此时就是把利润分解为每天为单元的维度，而不是从0天到第3天整体去考虑！

那么根据prices可以得到每天的利润序列：(prices[i] - prices[i-1])...(prices[1]-prices[0])。

如图：

![2-1-5-4](/assets/2-1-5-4.png)

可能有个疑问：第一天怎么就没有利润呢，第一天到底算不算。
第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！

从图中可以发现，其实我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间。

那么只收集正利润就是贪心所贪的地方！

局部最优：收集每天的正利润，全局最优：求得最大利润。

局部最优可以推出全局最优，找不出反例，试一试贪心！

* 时间复杂度O(n)
* 空间复杂度O(1)

```js
const maxProfit = (prices) => {
  let result = 0;
  for (let i = 1; i < prices.length; i++) {
    result += Math.max(prices[i] - prices[i - 1], 0);
  }
  return result;
}
```

### 总结
股票问题其实是一个系列的，属于动态规划的范畴，可以看出有时候，贪心往往比动态规划更巧妙，更好用，即：只收集每天的正利润，最后稳稳的就是最大利润了。