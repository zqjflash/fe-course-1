# 1-10 算法实战题集锦

## 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

* 思路：两层for循环查找，时间复杂度是O(n^2)。也可以使用map找差值减少一层循环。

```js
const twoSum = (nums, target) => {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;
  }
  return [];
}
```

## 2. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

* 思路：采用双指针法

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下表0的地方开始，同时定一个下表left 定义在i+1的位置上，定义下表right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下表就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：O(n^2)。

```js
const threeSum = (nums) => {
  const len = nums.length;
  if (len < 3) {
    return [];
  }
  nums.sort((a, b) => a - b); // 进行排序
  const res = [];
  for (let i = 0; i < len - 2; i++) {
    if (nums[i] > 0) {
      break;
    }
    // a去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let l = i + 1, r = len - 1;
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r];
      if (sum < 0) {
        l++;
        continue;
      }
      if (sum > 0) {
        r--;
        continue;
      }
      res.push([nums[i], nums[l], nums[r]])
      // b c 去重
      while(l < r && nums[l] === nums[++l]);
      while(l < r && nums[r] === nums[--r]);
    }
  }
  return res;
}
```

## 三、电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![2-1-10-1](/assets/2-1-10-1.png)

示例: 输入："23" 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

* 思路：回溯算法求组合问题，解决多层for循环带来的问题

需要解决三个问题：
1. 数字和字母如何映射；
 解法：可以使用map或者定义一个二维数组
2. 两个字母就两个for循环，三个字符就三个for循环，以此类推，代码根本写不出来；
 解法：使用回溯法来解决n个for循环的问题，例如：输入"23"抽象为树形结构，如图所示：
![2-1-10-2](/assets/2-1-10-2.png)
图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。

回溯三部曲：
* 确定回溯函数参数；需要一个字符串来收集叶子节点结果，然后用一个字符串数组result保存起来。
* 确定终止条件；终止条件就是如果index等于属于的数字个数
* 确定单层遍历逻辑；首先要取index指向的数字，并找到对应的字符集，然后for循环来处理这个字符集

3. 输入1*#按键等异常情况

```js
const letterCombinations = (digits) => {
  const k = digits.length;
  const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; // 使用map做数字和字母的映射
  if (!k) {
    return [];
  }
  if (k === 1) {
    return map[digits].split("");
  }

  const res = [], path = [];
  backtracking(digits, k, 0);
  return res;

  function backtracking(n, k, a) {
    if (path.length === k) {
      res.push(path.join(""));
      return;
    }
    for (const v of map[n[a]]) {
      path.push(v);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 四、四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

* 思路：双循环+双指针

四数之和，和三数之和一个解法，都是使用双指针法，基本解法就是在三数之和的基础之上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断nums[k] > target 就返回了，三数之和 可以通过 nums[i] > 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。

```js
const fourSum = (nums, target) => {
  const len = nums.length;
  if (len < 4) {
    return [];
  }
  nums.sort((a, b) => a - b);
  const res = [];
  for (let i = 0; i < len - 3; i++) {
    // 去重i
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    for (let j = i + 1; j < len - 2; j++) {
      // 去重j
      if (j > i + 1 && nums[j] === nums[j - 1]) {
        continue;
      }
      let l = j + 1, r = len - 1;
      while (l < r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        if (sum < target) {
          l++;
          continue;
        }
        if (sum > target) {
          r--;
          continue;
        }
        res.push([nums[i], nums[j], nums[l], nums[r]]);
        while (l < r && nums[l] === nums[++l]);
        while (l < r && nums[r] === nums[--r]);
      }
    }
  }
  return res;
}
```

## 五、删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 

示例 2：输入：head = [1], n = 1 输出：[] 示例 3：

示例 3：输入：head = [1,2], n = 1 输出：[1]

思路：
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

```js
const removeNthFromEnd = (head, n) => {
  let ret = new ListNode(0, head),
  slow = fast = ret;
  while(n--) {
    fast = fast.next; // fast移动n步
  }
  if (!fast) {
    return ret.next;
  }
  while(fast.next) {
    fast = fast.next;
    slow = slow.next;
  };
  slow.next = slow.next.next;
  return ret.next;
}
```

## 六、有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false

* 思路

括号匹配是使用栈解决的经典问题。
分析三种不匹配的情况：
1. 字符串里左方向的括号多余了，所以不匹配；
2. 括号没有多余，但是括号的类型没有匹配上；
3. 字符串里右方向的括号多余了，所以不匹配。

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

```js
const isValid = (s) => {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (c !== stack.pop()) {
          return false;
        }
    }
  }
  return stack.length === 0;
}
```

## 七、两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

* 思路：

建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

```js
const swapPairs = (head) => {
  let ret = new ListNode(0, head), temp = ret;
  while (temp.next && temp.next.next) {
    let cur = temp.next.next, pre = temp.next;
    pre.next = cur.next;
    cur.next = pre;
    temp.next = cur;
    temp = pre;
  }
  return ret.next;
}
```

## 八、 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

你不需要考虑数组中超出新长度后面的元素。

* 思路

要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。
双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

```js
const removeElement = (nums, val) => {
  let k = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != val) {
      nums[k++] = nums[i];
    }
  }
  return k;
}
```

## 九、实现strStr()
> 在一个串中查找是否出现过另一个串，这是KMP的看家本领。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。

KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。

```js
const strStr = (haystack, needle) => {
  if (needle.length === 0 || (haystack.length === 0 && needle.length === 0)) {
    return 0;
  }
  if (haystack.length === 0) {
    return -1;
  }
  return haystack.indexOf(needle);
}
```

## 10. 插入搜索位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1: 输入: [1,3,5,6], 5 输出: 2

示例 2: 输入: [1,3,5,6], 2 输出: 1

示例 3: 输入: [1,3,5,6], 7 输出: 4

示例 4: 输入: [1,3,5,6], 0 输出: 0

* 思路
 * 目标值在数组所有元素之前
 * 目标值等于数组中某一个元素
 * 目标值插入数组中的位置
 * 目标值在数组所有元素之后

* 解法：二分法
大家注意这道题目的前提是数组是有序数组，这也是使用二分查找的基础条件。
要在二分查找的过程中，保持不变量，这也就是循环不变量。

```js
const searchInsert = (nums, target) => {
  let l = 0, r = nums.length - 1, ans = nums.length;
  while (l <= r) {
    const mid = l + Math.floor((r - l) >> 1);
    if (target > nums[mid]) {
      l = mid + 1;
    } else {
      ans = mid;
      r = mid -1;
    }
  }
  return ans;
}
```

## 11. 解数独

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。

提示：
* 给定的数独序列只包含数字1-9和字符'.'
* 你可以假设给定的数独只有唯一解；
* 给定数独永远是9*9形式的。

### 思路 双循环+递归
棋盘搜索问题可以使用回溯法暴力搜搜，只不过这次我们要做的是二维递归。
本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深。

![2-1-10-3](/assets/2-1-10-3.png)

* 解法

回溯三部曲：

1. 递归函数以及参数
递归函数的返回值需要是bool类型，为什么呢？
因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值，

2. 递归终止条件
本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

3. 那么有没有永远填不满的情况呢？
一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！

```js
const solveSudoku = (board) => {
  function isValid(row, col, val, board) {
    let len = board.length;
    // 行不能重复
    for (let i = 0; i < len; i++) {
      if (board[row][i] === val) {
        return false;
      }
    }
    // 列不能重复
    for (let i = 0; i < len; i++) {
      if (board[i][col] === val) {
        return false;
      }
    }
    let startRow = Math.floor(row / 3) * 3;
    let startCol = Math.floor(col / 3) * 3;
    for (let i = startRow; i < startRow + 3; i++) {
      for (let j = startCol; j < startCol + 3; j++) {
        if (board[i][j] === val) {
          return false;
        }
      }
    }
    return true;
  }
  function backTracking() {
    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[0].length; j++) {
        if (board[i][j] !== '.') {
          continue;
        }
        for (let val = 1; val <= 9; val++) {
          if (isValid(i, j, `${val}`, board)) {
            board[i][j] = `${val}`
            if (backTracking()) {
              return true;
            }
            board[i][j] = `.`
          }
        }
        return false;
      }
    }
    return true;
  }
  backTracking(board);
  return board;
}
```

## 12、组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：
* 所有数字（包括target）都是正整数；
* 解集不能包含重复的组合。

示例1： 输入：candidates = [2, 3, 6, 7], target = 7, 所求解集为：[[7],[2,2,3]]

示例2：输入：candidates = [2, 3, 5], target=8,所求解集为：[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

* 思路
本题搜索的过程抽象成树形结构如下：
![2-1-10-4](/assets/2-1-10-4.png)

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

* 回溯三部曲
1. 递归函数参数
这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）
2. 递归终止条件
从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。
sum等于target的时候，需要收集结果，代码如下：

```js
if (sum > target) {
  return;
}
if (sum == target) {
  result.push_back(path);
  return;
}
```
3. 单层搜索的逻辑
单层for循环依然是从startIndex开始，搜索candidates集合。
for循环剪枝代码优化：
```js
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

实现代码：

```js
const combinationSum = (candidates, target) => {
  const res = [], path = []; // path存放符合条件的结果
  candidates.sort(); // 排序
  backtracking(0, 0);
  return res;
  // 递归：深搜
  function backtracking(j, sum) {
    if (sum > target) {
      return; // 剪枝
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    // 广搜
    for (let i = j; i < candidates.length; i++) {
      const n = candidates[i];
      if (n > target - sum) {
        continue;
      }
      path.push(n);
      sum += n;
      backtracking(i, sum);
      path.pop();
      sum -= n;
    }
  }
}
```

## 13、组合总和II

给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。

candidates中的每个数字在每个组合中只能使用一次。

说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。
示例1：输入：candidates = [10, 1, 2, 7, 6, 1, 5]，target = 8，所求解集为：[[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]

示例2：输入：candidates = [2, 5, 2, 1, 2]，target = 5，所求解集为：[[1, 2, 2], [5]]

* 思路

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

所谓去重，其实就是使用过的元素不能重复选取。

组合问题可以抽象为树形结构，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。

我们要去重的是同一树层上的使用过，同一树枝上的都是一个组合里的元素，不用去重。
树层去重，需要对数组进行排序。

* 递归函数参数：需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。
* 递归终止条件：终止条件为sum > target和sum == target
* 单层搜索的逻辑
candidates[i] == candidates[i-1]并且used[i-1]==false，就说明前一个树枝，使用了candidates[i-1]，也就是说同一树层使用过candidates[i-1]。

```js
const combinationSum2 = (candidates, target) => {
  const res = [], path = [], len = candidates.length;
  candidates.sort();
  backtracking(0, 0);
  return res;

  function backtracking(sum, i) {
    if (sum > target) {
      return;
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    let f = -1;
    for (let j = i; j < len; j++) {
      const n = candidates[j];
      if (n > target - sum || n === f) {
        continue;
      }
      path.push(n);
      sum += n;
      f = n;
      backtracking(sum, j + 1);
      path.pop();
      sum -= n;
    }
  }
}
```

## 14、跳跃游戏II

给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例：输入：[2, 3, 1, 1, 4]输出：2
解释：跳到最后一个位置的最小跳跃数是2.从下标为0跳到下标为1的位置，跳1步，然后跳3步到达数组的最后一个位置。

说明：假设你总是可以到达数组的最后一个位置。

* 思路 贪心算法
要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！

贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。

```js
const jump = (nums) => {
  let curIndex = 0;
  let nextIndex = 0;
  let steps = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex);
    if (i === curIndex) {
      curIndex = nextIndex;
      steps++;
    }
  }
  return steps;
}
```

## 15、全排列

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：输入：[1,2,3]，输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

* 思路

循环+回溯法
for循环：横向遍历；
递归：纵向遍历；

回溯三部曲：
* 递归函数参数：首先排列是有序的，也就是说[1,2]和[2,1]是两个集合，这和之前分析的子集以及组合所不同的地方。可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用starIndex了。但排列问题需要一个used数组，标记已经选择的元素。

* 递归终止条件：可以看出叶子节点，就是收割结果的地方，当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

* 单层搜索的逻辑：因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用了，但是在[2,1]中还要再使用一次1。而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。

```js
const permute = (nums) => {
  const res = [], path = [];
  backtracking(nums, nums.length, []);
  return res;
  function backtracking(n, k, used) {
    if (path.length === k) {
      res.push(Array.from(path));
      return;
    }
    for (let i = 0; i < k; i++) {
      if (used[i]) {
        continue;
      }
      path.push(n[i]);
      used[i] = true; // 同枝
      backtracking(n, k, used);
      path.pop();
      used[i] = false;
    }
  }
}
```

## 16、全排列II

给定一个可包含重复数字的序列nums，按任意顺序返回所有不重复的全排列。

示例1：输入：nums = [1, 1, 2] 输出：[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
示例2：输入：nums[1, 2, 3]，输出：[[1,2,3], [1,3,2], [2,1,3], [3,1,2],[3,2,1]]

提示：
* 1<= nums.length <= 8
* -10 <= nums[i] <= 10

### 思路
采用回溯法，涉及去重，还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。

一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。

对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！

```js
const permuteUnique = (nums) => {
  const result = [], path = [];
  nums.sort();
  backtracking([]);
  return result;
  function backtracking(used) {
    if (path.length === nums.length) {
      result.push(path.slice());
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
        continue;
      }
      if (!used[i]) {
        used[i] = true;
        path.push(nums[i]);
        backtracking(used);
        path.pop();
        used[i] = false;
      }
    }
  }
}
```

## 17、N皇后

n皇后问题研究的是如何将n个皇后放置在n*n的棋盘上，并且使皇后彼此之间不能相互攻击。
给定一个整数n，返回所有不同的n皇后问题的解决方案。
每一种解法包含一个明确的n皇后问题的棋子放置方案，该方案中'Q'和'.'分别代表了皇后和空位。

示例：输入4，输出：[[".Q..", // 解法1"...Q", "Q...", "..Q."],
["..Q.", // 解法2 "Q...", "...Q",".Q.."]]
解释：4皇后问题存在两个不同的解法。

### 思路
n皇后问题是回溯算法解决的经典问题，回溯可解决组合、切割、子集、排列问题之后，对二维矩阵有一些挑战。

对皇后的约束条件：
1. 不能同行；
2. 不能同列；
3. 不能同斜线；（40度和135度角）

* 回溯三部曲
1. 递归函数参数：定义全局变量二维数组result来记录最终结果；参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。

2. 递归终止条件
当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

3. 单层搜索的逻辑
递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

```js
const solveQueens = (n) => {
  function isValid(row, col, chessBoard, n) {
    for (let i = 0; i < row; i++) {
      if (chessBoard[i][col] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    return true;
  }

  function transformChessBoard(chessBoard) {
    let chessBoardBack = [];
    chessBoard.forEach(row => {
      let rowStr = '';
      row.forEach(value => {
        rowStr += value
      })
      chessBoardBack.push(rowStr)
    })
    return chessBoardBack;
  }

  let result = [];
  function backtracking(row, chessBoard) {
    if (row === n) {
      result.push(transformChessBoard(chessBoard));
      return;
    }
    for (let col = 0; col < n; col++) {
      if (isValid(row, col, chessBoard, n)) {
        chessBoard[row][col] = 'Q';
        backtracking(row + 1, chessBoard);
        chessBoard[row][col] = '.';
      }
    }
  }
  let chessBoard = new Array(n).fill([]).map(() => new Array(n).fill('.'));
  backtracking(0, chessBoard);
  return result;
}
```