# 1-10 算法实战题集锦

## 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

* 思路：两层for循环查找，时间复杂度是O(n^2)。也可以使用map找差值减少一层循环。

```js
const twoSum = (nums, target) => {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;
  }
  return [];
}
```

## 2. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

* 思路：采用双指针法

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下表0的地方开始，同时定一个下表left 定义在i+1的位置上，定义下表right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下表就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：O(n^2)。

```js
const threeSum = (nums) => {
  const len = nums.length;
  if (len < 3) {
    return [];
  }
  nums.sort((a, b) => a - b); // 进行排序
  const res = [];
  for (let i = 0; i < len - 2; i++) {
    if (nums[i] > 0) {
      break;
    }
    // a去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let l = i + 1, r = len - 1;
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r];
      if (sum < 0) {
        l++;
        continue;
      }
      if (sum > 0) {
        r--;
        continue;
      }
      res.push([nums[i], nums[l], nums[r]])
      // b c 去重
      while(l < r && nums[l] === nums[++l]);
      while(l < r && nums[r] === nums[--r]);
    }
  }
  return res;
}
```

## 三、电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![2-1-10-1](/assets/2-1-10-1.png)

示例: 输入："23" 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

* 思路：回溯算法求组合问题，解决多层for循环带来的问题

需要解决三个问题：
1. 数字和字母如何映射；
 解法：可以使用map或者定义一个二维数组
2. 两个字母就两个for循环，三个字符就三个for循环，以此类推，代码根本写不出来；
 解法：使用回溯法来解决n个for循环的问题，例如：输入"23"抽象为树形结构，如图所示：
![2-1-10-2](/assets/2-1-10-2.png)
图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。

回溯三部曲：
* 确定回溯函数参数；需要一个字符串来收集叶子节点结果，然后用一个字符串数组result保存起来。
* 确定终止条件；终止条件就是如果index等于属于的数字个数
* 确定单层遍历逻辑；首先要取index指向的数字，并找到对应的字符集，然后for循环来处理这个字符集

3. 输入1*#按键等异常情况

```js
const letterCombinations = (digits) => {
  const k = digits.length;
  const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; // 使用map做数字和字母的映射
  if (!k) {
    return [];
  }
  if (k === 1) {
    return map[digits].split("");
  }

  const res = [], path = [];
  backtracking(digits, k, 0);
  return res;

  function backtracking(n, k, a) {
    if (path.length === k) {
      res.push(path.join(""));
      return;
    }
    for (const v of map[n[a]]) {
      path.push(v);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 四、四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

* 思路：双循环+双指针

四数之和，和三数之和一个解法，都是使用双指针法，基本解法就是在三数之和的基础之上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断nums[k] > target 就返回了，三数之和 可以通过 nums[i] > 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。

```js
const fourSum = (nums, target) => {
  const len = nums.length;
  if (len < 4) {
    return [];
  }
  nums.sort((a, b) => a - b);
  const res = [];
  for (let i = 0; i < len - 3; i++) {
    // 去重i
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    for (let j = i + 1; j < len - 2; j++) {
      // 去重j
      if (j > i + 1 && nums[j] === nums[j - 1]) {
        continue;
      }
      let l = j + 1, r = len - 1;
      while (l < r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        if (sum < target) {
          l++;
          continue;
        }
        if (sum > target) {
          r--;
          continue;
        }
        res.push([nums[i], nums[j], nums[l], nums[r]]);
        while (l < r && nums[l] === nums[++l]);
        while (l < r && nums[r] === nums[--r]);
      }
    }
  }
  return res;
}
```

## 五、删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 

示例 2：输入：head = [1], n = 1 输出：[] 示例 3：

示例 3：输入：head = [1,2], n = 1 输出：[1]

思路：
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

```js
const removeNthFromEnd = (head, n) => {
  let ret = new ListNode(0, head),
  slow = fast = ret;
  while(n--) {
    fast = fast.next; // fast移动n步
  }
  if (!fast) {
    return ret.next;
  }
  while(fast.next) {
    fast = fast.next;
    slow = slow.next;
  };
  slow.next = slow.next.next;
  return ret.next;
}
```

## 六、有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false

* 思路

括号匹配是使用栈解决的经典问题。
分析三种不匹配的情况：
1. 字符串里左方向的括号多余了，所以不匹配；
2. 括号没有多余，但是括号的类型没有匹配上；
3. 字符串里右方向的括号多余了，所以不匹配。

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

```js
const isValid = (s) => {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (c !== stack.pop()) {
          return false;
        }
    }
  }
  return stack.length === 0;
}
```

## 七、两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

* 思路：

建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

```js
const swapPairs = (head) => {
  let ret = new ListNode(0, head), temp = ret;
  while (temp.next && temp.next.next) {
    let cur = temp.next.next, pre = temp.next;
    pre.next = cur.next;
    cur.next = pre;
    temp.next = cur;
    temp = pre;
  }
  return ret.next;
}
```

## 八、 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

你不需要考虑数组中超出新长度后面的元素。

* 思路

要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。
双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

```js
const removeElement = (nums, val) => {
  let k = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != val) {
      nums[k++] = nums[i];
    }
  }
  return k;
}
```

## 九、实现strStr()
> 在一个串中查找是否出现过另一个串，这是KMP的看家本领。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。

KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。

```js
const strStr = (haystack, needle) => {
  if (needle.length === 0 || (haystack.length === 0 && needle.length === 0)) {
    return 0;
  }
  if (haystack.length === 0) {
    return -1;
  }
  return haystack.indexOf(needle);
}
```

## 10. 插入搜索位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1: 输入: [1,3,5,6], 5 输出: 2

示例 2: 输入: [1,3,5,6], 2 输出: 1

示例 3: 输入: [1,3,5,6], 7 输出: 4

示例 4: 输入: [1,3,5,6], 0 输出: 0

* 思路
 * 目标值在数组所有元素之前
 * 目标值等于数组中某一个元素
 * 目标值插入数组中的位置
 * 目标值在数组所有元素之后

* 解法：二分法
大家注意这道题目的前提是数组是有序数组，这也是使用二分查找的基础条件。
要在二分查找的过程中，保持不变量，这也就是循环不变量。

```js
const searchInsert = (nums, target) => {
  let l = 0, r = nums.length - 1, ans = nums.length;
  while (l <= r) {
    const mid = l + Math.floor((r - l) >> 1);
    if (target > nums[mid]) {
      l = mid + 1;
    } else {
      ans = mid;
      r = mid -1;
    }
  }
  return ans;
}
```

## 11. 解数独

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。

提示：
* 给定的数独序列只包含数字1-9和字符'.'
* 你可以假设给定的数独只有唯一解；
* 给定数独永远是9*9形式的。

### 思路 双循环+递归
棋盘搜索问题可以使用回溯法暴力搜搜，只不过这次我们要做的是二维递归。
本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深。

![2-1-10-3](/assets/2-1-10-3.png)

* 解法

回溯三部曲：

1. 递归函数以及参数
递归函数的返回值需要是bool类型，为什么呢？
因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值，

2. 递归终止条件
本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

3. 那么有没有永远填不满的情况呢？
一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！

```js
const solveSudoku = (board) => {
  function isValid(row, col, val, board) {
    let len = board.length;
    // 行不能重复
    for (let i = 0; i < len; i++) {
      if (board[row][i] === val) {
        return false;
      }
    }
    // 列不能重复
    for (let i = 0; i < len; i++) {
      if (board[i][col] === val) {
        return false;
      }
    }
    let startRow = Math.floor(row / 3) * 3;
    let startCol = Math.floor(col / 3) * 3;
    for (let i = startRow; i < startRow + 3; i++) {
      for (let j = startCol; j < startCol + 3; j++) {
        if (board[i][j] === val) {
          return false;
        }
      }
    }
    return true;
  }
  function backTracking() {
    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[0].length; j++) {
        if (board[i][j] !== '.') {
          continue;
        }
        for (let val = 1; val <= 9; val++) {
          if (isValid(i, j, `${val}`, board)) {
            board[i][j] = `${val}`
            if (backTracking()) {
              return true;
            }
            board[i][j] = `.`
          }
        }
        return false;
      }
    }
    return true;
  }
  backTracking(board);
  return board;
}
```

## 12、组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：
* 所有数字（包括target）都是正整数；
* 解集不能包含重复的组合。

示例1： 输入：candidates = [2, 3, 6, 7], target = 7, 所求解集为：[[7],[2,2,3]]

示例2：输入：candidates = [2, 3, 5], target=8,所求解集为：[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

* 思路
本题搜索的过程抽象成树形结构如下：
![2-1-10-4](/assets/2-1-10-4.png)

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

* 回溯三部曲
1. 递归函数参数
这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）
2. 递归终止条件
从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。
sum等于target的时候，需要收集结果，代码如下：

```js
if (sum > target) {
  return;
}
if (sum == target) {
  result.push_back(path);
  return;
}
```
3. 单层搜索的逻辑
单层for循环依然是从startIndex开始，搜索candidates集合。
for循环剪枝代码优化：
```js
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

实现代码：

```js
const combinationSum = (candidates, target) => {
  const res = [], path = []; // path存放符合条件的结果
  candidates.sort(); // 排序
  backtracking(0, 0);
  return res;
  // 递归：深搜
  function backtracking(j, sum) {
    if (sum > target) {
      return; // 剪枝
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    // 广搜
    for (let i = j; i < candidates.length; i++) {
      const n = candidates[i];
      if (n > target - sum) {
        continue;
      }
      path.push(n);
      sum += n;
      backtracking(i, sum);
      path.pop();
      sum -= n;
    }
  }
}
```

## 13、组合总和II

给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。

candidates中的每个数字在每个组合中只能使用一次。

说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。
示例1：输入：candidates = [10, 1, 2, 7, 6, 1, 5]，target = 8，所求解集为：[[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]

示例2：输入：candidates = [2, 5, 2, 1, 2]，target = 5，所求解集为：[[1, 2, 2], [5]]

* 思路

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

所谓去重，其实就是使用过的元素不能重复选取。

组合问题可以抽象为树形结构，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。

我们要去重的是同一树层上的使用过，同一树枝上的都是一个组合里的元素，不用去重。
树层去重，需要对数组进行排序。

* 递归函数参数：需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。
* 递归终止条件：终止条件为sum > target和sum == target
* 单层搜索的逻辑
candidates[i] == candidates[i-1]并且used[i-1]==false，就说明前一个树枝，使用了candidates[i-1]，也就是说同一树层使用过candidates[i-1]。

```js
const combinationSum2 = (candidates, target) => {
  const res = [], path = [], len = candidates.length;
  candidates.sort();
  backtracking(0, 0);
  return res;

  function backtracking(sum, i) {
    if (sum > target) {
      return;
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    let f = -1;
    for (let j = i; j < len; j++) {
      const n = candidates[j];
      if (n > target - sum || n === f) {
        continue;
      }
      path.push(n);
      sum += n;
      f = n;
      backtracking(sum, j + 1);
      path.pop();
      sum -= n;
    }
  }
}
```

## 14、跳跃游戏II

给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例：输入：[2, 3, 1, 1, 4]输出：2
解释：跳到最后一个位置的最小跳跃数是2.从下标为0跳到下标为1的位置，跳1步，然后跳3步到达数组的最后一个位置。

说明：假设你总是可以到达数组的最后一个位置。

* 思路 贪心算法
要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！

贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。

```js
const jump = (nums) => {
  let curIndex = 0;
  let nextIndex = 0;
  let steps = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex);
    if (i === curIndex) {
      curIndex = nextIndex;
      steps++;
    }
  }
  return steps;
}
```

## 15、全排列

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：输入：[1,2,3]，输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

* 思路

循环+回溯法
for循环：横向遍历；
递归：纵向遍历；

回溯三部曲：
* 递归函数参数：首先排列是有序的，也就是说[1,2]和[2,1]是两个集合，这和之前分析的子集以及组合所不同的地方。可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用starIndex了。但排列问题需要一个used数组，标记已经选择的元素。

* 递归终止条件：可以看出叶子节点，就是收割结果的地方，当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

* 单层搜索的逻辑：因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用了，但是在[2,1]中还要再使用一次1。而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。

```js
const permute = (nums) => {
  const res = [], path = [];
  backtracking(nums, nums.length, []);
  return res;
  function backtracking(n, k, used) {
    if (path.length === k) {
      res.push(Array.from(path));
      return;
    }
    for (let i = 0; i < k; i++) {
      if (used[i]) {
        continue;
      }
      path.push(n[i]);
      used[i] = true; // 同枝
      backtracking(n, k, used);
      path.pop();
      used[i] = false;
    }
  }
}
```

## 16、全排列II

给定一个可包含重复数字的序列nums，按任意顺序返回所有不重复的全排列。

示例1：输入：nums = [1, 1, 2] 输出：[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
示例2：输入：nums[1, 2, 3]，输出：[[1,2,3], [1,3,2], [2,1,3], [3,1,2],[3,2,1]]

提示：
* 1<= nums.length <= 8
* -10 <= nums[i] <= 10

### 思路
采用回溯法，涉及去重，还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。

一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。

对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！

```js
const permuteUnique = (nums) => {
  const result = [], path = [];
  nums.sort();
  backtracking([]);
  return result;
  function backtracking(used) {
    if (path.length === nums.length) {
      result.push(path.slice());
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
        continue;
      }
      if (!used[i]) {
        used[i] = true;
        path.push(nums[i]);
        backtracking(used);
        path.pop();
        used[i] = false;
      }
    }
  }
}
```

## 17、N皇后

n皇后问题研究的是如何将n个皇后放置在n*n的棋盘上，并且使皇后彼此之间不能相互攻击。
给定一个整数n，返回所有不同的n皇后问题的解决方案。
每一种解法包含一个明确的n皇后问题的棋子放置方案，该方案中'Q'和'.'分别代表了皇后和空位。

示例：输入4，输出：[[".Q..", // 解法1"...Q", "Q...", "..Q."],
["..Q.", // 解法2 "Q...", "...Q",".Q.."]]
解释：4皇后问题存在两个不同的解法。

### 思路
n皇后问题是回溯算法解决的经典问题，回溯可解决组合、切割、子集、排列问题之后，对二维矩阵有一些挑战。

对皇后的约束条件：
1. 不能同行；
2. 不能同列；
3. 不能同斜线；（40度和135度角）

* 回溯三部曲
1. 递归函数参数：定义全局变量二维数组result来记录最终结果；参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。

2. 递归终止条件
当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

3. 单层搜索的逻辑
递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

```js
const solveQueens = (n) => {
  function isValid(row, col, chessBoard, n) {
    for (let i = 0; i < row; i++) {
      if (chessBoard[i][col] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    return true;
  }

  function transformChessBoard(chessBoard) {
    let chessBoardBack = [];
    chessBoard.forEach(row => {
      let rowStr = '';
      row.forEach(value => {
        rowStr += value
      })
      chessBoardBack.push(rowStr)
    })
    return chessBoardBack;
  }

  let result = [];
  function backtracking(row, chessBoard) {
    if (row === n) {
      result.push(transformChessBoard(chessBoard));
      return;
    }
    for (let col = 0; col < n; col++) {
      if (isValid(row, col, chessBoard, n)) {
        chessBoard[row][col] = 'Q';
        backtracking(row + 1, chessBoard);
        chessBoard[row][col] = '.';
      }
    }
  }
  let chessBoard = new Array(n).fill([]).map(() => new Array(n).fill('.'));
  backtracking(0, chessBoard);
  return result;
}
```

## 18、最大子序和

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例： 输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6，解释：连续子数组[4, -1, 2, 1]的和最大，为6

## 思路：看到连续和使用贪心
贪心解法
* 贪心贪的是哪里呢？
如果是-2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素"连续和"只会越来越小。
全局最优：选取最大“连续和”

* 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么久应该从nums[i+1]开始从0累积count了。因为已经变为负数的count，只会拖累总和。

* 暴力解法中的不断调整最大子序和区间的起始位置。

```js
const maxSubArray = (nums) => {
  let result = -Infinity;
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    count += nums[i];
    if (count > result) {
      result = count;
    }
    if (count < 0) {
      count = 0;
    }
  }
  return result;
}
```

## 19、最大子序和
给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例：输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4] 输出：6
解释：连续子数组[4, -1, 2, 1]的和最大，为6.

### 思路
可以使用贪心算法，也可以使用动态规划

本次使用动态规划来解题：

* 动态规划五部曲：

1. 确定dp数组(dp table)以及下标的含义
dp[i]：包括下标i之前的最大连续子序列和为dp[i]。

2. 确定递推公式
dp[i]只有两个方向可以推出来：
* dp[i - 1] + nums[i]，即nums[i]加入当前连续子序列和
* nums[i]，即从头开始计算当前连续子序列和
一定是取最大的，所以dp[i] = max(dp[i-1] + nums[i], nums[i])

3. dp数组如何初始化
从递推公式可以看出来dp[i]是依赖于dp[i-1]的状态，dp[0]就是递推公式的基础。
dp[0]=nums[0]

4. 确定遍历顺序
递推公式中dp[i]依赖于dp[i-1]的状态，需要从前向后遍历。

5. 举例推导dp数组
注意最后的结果的是dp[i]对应最大的元素

```js
const maxSubArray = (nums) => {
  if (nums.length == 0) {
    return 0;
  }
  let res = nums[0];
  let dp = [];
  dp[0] = nums[0]; // 初始化都为0
  // 遍历方向从前往后
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); // 递推公式，dp[i]代表当前下标对应的最大值
    res = res > dp[i] ? res : dp[i];
  }
  return res;
}
```

## 20、跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

示例1：输入[2,3,1,1,4]，输出:true，解释：我们可以先跳1步，从位置0到达位置1，然后再从位置1跳3步到达最后一个位置。

示例2：输入[3,2,1,0,4]，输出：false，解释：无论怎样，你总会到达索引为3的位置。但该位置的足底啊跳跃长度是0，所以你永远不可能到达最后一个位置。

* 思路
贪心算法
核心问题：跳跃覆盖范围究竟可不可以覆盖到终点！每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。
每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。局部最优推出全局最优。

```js
const canJump = (nums) => {
  if (nums.length === 1) {
    return true;
  }
  let cover = 0;
  for (let i = 0; i <= cover; i++) {
    cover = Math.max(cover, nums[i] + i);
    if (cover >= nums.length - 1) {
      return true;
    }
  }
  return false;
}
```

## 21、合并区间

给出一个区间的集合，请合并所有重叠的区间。
示例1：输入intervals = [[1,3], [2,6], [8, 10], [15, 18]]，输出[[1,6],[8,10],[15,18]] 解释：区间[1,3]和[2,6]重叠，将它们合并为[1,6]

示例2：输入intervals=[[1,4],[4,5]] 输出:[[1,5]]，解释：区间[1,4]和[4,5]可被视为重叠区间。

提示：
* intervals[i][0] <= intervals[i][1]

### 思路 - 贪心
1. 首先需要先排序；
2. 排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。
intervals[i]的左边界在intervals[i-1]的左边界和右边界的范围内，那么一定有重复。

```js
const merge = (intervals) => {
  intervals.sort((a, b) => a[0] - b[0]);
  let prev = intervals[0];
  let result = [];
  for (let i = 0; i < intervals.length; i++) {
    let cur = intervals[i];
    if (cur[0] > prev[1]) {
      result.push(prev);
      prev = cur;
    } else {
      prev[1] = Math.max(cur[1], prev[1])
    }
  }
  result.push(prev);
  return result;
}
```

## 22、螺旋矩阵II

给定一个正整数n，生成一个包含1到n2的所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例：输入：3，输出：[[1,2,3],[8,9,4][7,6,5]]

* 思路：
循环不变量原则
模拟顺时针画矩阵的过程：
* 填充上行从左到右；
* 填充右列从上到下；
* 填充下行从右到左；
* 填充左列从下到上。
由外向内一圈一圈这么画下去。

按照左闭右开的原则，如下图：

![2-1-10-5](/assets/2-1-10-5.png)

```js
const generateMatrix = (n) => {
  //使用fill->填充的是同一个数组地址
  const res = Array.from({length: n}).map(() => new Array(n));
  let loop = n >> 1, i = 0, // 循环次数
  count = 1,
  startX = startY = 0; // 起始位置
  while (++i <= loop) {
    // 定义行列
    let row = startX, column = startY;
    // [startY, n - i)
    while (column < n - i) {
      res[row][column++] = count++;
    }
    // [startX, n - i)
    while (row < n - i) {
      res[row++][column] = count++;
    }
    // [n - i, startY)
    while(column > startY) {
      res[row][column--] = count++;
    }
    // [n - i, startX)
    while (row > startX) {
      res[row--][column] = count++;
    }
    startX = ++startY;
  }
  if (n & 1) {
    res[startX][startY] = count;
  }
  return res;
}
```

## 23、不同路径

一个机器人位于一个m*n的网格的左上角（起始点在下图中标记为"Start"）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为"Finish"）。
问总共有多少条不同的路径。

示例：输入m = 3, n = 7,输出：28
示例：输入m = 2, n = 3 输出：3 解释：从左上角开始，总共有3条路径可以到达右下角。
1. 向右->向右->向下
2. 向右-> 向下->向右
3. 向下->向右->向右

* 思路
动态规划：机器人从(0,0)位置出发，到(m-1,n-1)终点。

动态规划五部曲：
1. 确定dp数组以及下标的含义；
dp[i][j]：表示从(0, 0)出发，到(i,j)有dp[i][j]条不同的路径；
2. 确定递推公式
想要求dp[i][j]，只能有两个方向来推导出来，即dp[i-1][j]和dp[i][j-1]
此时在回顾一下dp[i-1][j]表示啥，是从(0,0)的位置到(i-1,j)有几条路径，dp[i][j-1]同理。
dp[i][j] = dp[i-1][j] + dp[i][j-1]，因为dp[i][j]只有这两个方向过来。
3. dp数组的初始化
如何初始化呢？首先dp[i][0]一定都是1，因为从(0,0)的位置到(i,0)的路径只有一条，那么dp[0][j]也同理。
所以初始化代码为：
```js
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```
4. 确定遍历顺序
这里要看一下递归公式dp[i][j] = dp[i-1][j] + dp[i][j-1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
这样就可以保证推导dp[i][j]的时候，dp[i-1][j]和dp[i][j-1]一定是有数值的。

5. 举例推导dp数组

```js
const uniquePaths = (m, n) => {
  const dp = Array(m).fill().map(item => Array(n)); // 初始化m*n空数组

  for (let i = 0; i < m; ++i) {
    dp[i][0] = 1;
  }

  for (let i = 0; i < n; ++i) {
    dp[0][i] = 1;
  }

  for (let i = 1; i < m; ++i) {
    for (let j = 1; j < n; ++j) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m-1][n-1];
}
```

## 24、不同路径II

一个机器人位于一个m*n网格的左上角（起始点在下图中标记为"Start"）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为"Finish"）。
现在考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？

示例1：网格中的障碍物和空位置分别用1和0来表示。
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2
解释：3*3网格的正中间有一个障碍物，从左上角到右下角一共有2条不同的路径：
1. 向右->向右->向下->向下;
2. 向下->向下->向右->向右;

* 思考
动态规划，有障碍的话，其实就是标记对应的dp table保持初始值(0)就可以了。

* 动态五部曲：

1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：表示从(0,0)出发，到(i,j)有dp[i][j]条不同的路径。

2. 确定递推公式
递推公式dp[i][j] = dp[i-1][j] + dp[i][j - 1];
这里要注意一点，因为有了障碍，(i,j)如果就是障碍的话应该就保持初始状态（初始状态为0）。
```js
if (obstacleGrid[i][j] == 0) {
  dp[i][j] = dp[i-1][j] + dp[i][j-1]; // 当(i,j)没有障碍的时候，再推导dp[i][j]
}
```

3. dp数组如何初始化
从(0,0)的位置到(i,0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理；
但如果(i,0)这条边有了障碍之后，障碍之后（包括障碍）都是走不动的位置，所以障碍之后的dp[i][0]应该还是初始值0。
注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理。

4. 确定遍历顺序
从递归公式dp[i][j] = dp[i-1][j] + dp[i][j-1]中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i-1][j]和dp[i][j-1]一定是有数值。

5. 举例推导dp数组

```js
const uniquePathsWithObstacles = (obstacleGrid) => {
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;
  const dp = Array(m).fill().map(item => Array(n).fill(0));

  for (let i = 0; i < m && obstacleGrid[i][0] === 0; ++i) {
    dp[i][0] = 1;
  }

  for (let i = 1; i < n && obstacleGrid[0][i] === 0; ++i) {
    dp[0][i] = 1;
  }

  for (let i = 1; i < m; ++i) {
    for (let j = 1; j < n; ++j) {
      dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
}
```

## 25、爬楼梯

假设你正在爬楼梯，需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定n是一个正整数。
示例1：输入2，输出2，解释：有两种方法可以爬到楼顶。
1. 1阶+1阶
2. 2阶

示例2：输入：3 输出3 解释：有三种方法可以爬到楼顶。
1. 1阶+1阶+1阶
2. 1阶+2阶
3. 2阶+1阶

* 思路：动态规划

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
那么第一层楼梯再跨两步就到第三层，第二层楼梯再跨一步就到第三层。
所以到第三层楼梯的状态可以由第二层楼梯和到第一层楼梯状态推导出来，可以使用动态规划。

动态规划5部曲
1. 确定dp数组以及下标的含义
dp[i]:爬到第i层楼梯，有dp[i]种方法；
2. 确定递推公式：
从dp[i]的定义可以看出，dp[i]可以有两个方向推出来。
首先dp[i-1]，上i-1层楼梯，有dp[i-1]种方法，那么再一步跳一个台阶就是dp[i]
dp[i-2]，上i-2层楼梯，有dp[i-2]种方法，那么再一步跳两个台阶就是dp[i]
所以：dp[i] = dp[i-1] + dp[i-2]
3. dp数组如何初始化
dp[i] = 1, dp[2] = 2, 然后从i=3开始递推，这样符合dp[i]的定义。
4. 确定遍历顺序
从递推公式dp[i] = dp[i-1] + dp[i-2]中可以看出，遍历顺序一定是从前向后遍历的。
5. 举例推导dp数组
举例当n为5的时候，dp[5]应该8

发现就是斐波那契

```js
const climbStairs = (n) => {
  // dp[i] 为第i阶楼梯有多少种方法爬到楼顶
  // dp[i] = dp[i-1] + dp[i-2]
  let dp = [1, 2];
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i -1] + dp[i - 2];
  }
  return dp[n - 1];
}
```

## 26、爬楼梯完全背包版本

假设你正在爬楼梯，需要n阶你才能到达楼顶。
一步1个台阶，两个台阶，三个台阶，...，直到m个台阶，你有多少种不同的方法可以爬到楼顶呢？

* 思路：动态规划 + 完全背包
这是一个完全背包问题了

动态规划5部曲：
1. 确定dp数组以及下标的含义；
dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。
2. 确定递推公式
装满背包的递推公式一般都是dp[i] += dp[i - nums[j]]，
本题，dp[i]有几种来源，dp[i-1], dp[i-2],dp[i-3]，那么递推公式为：dp[i] += dp[i - j]
3. dp数组如何初始化
既然递归公式是dp[i] += dp[i - j]，那么dp[0]一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。
4. 确定遍历顺序
这是背包里求排列问题，即：1、2步和2、1步都是上三个台阶，但是方法不同。
所以需要将target放在外循环，nums放在内循环。
5. 举例来推导dp数组
dp[4] = dp[3] + dp[2] + dp[1] = 7

```js
const climbStairs = (n) => {
  let dp = [1];
  let weight = [1, 2];
  for (let i = 0; i <= n; i++) {
    for (let j = 0; j < weight.length; j++) {
      if (i >= weight[j]) {
        dp[i] += dp[i - weight[j]];
      }
    }
  }
  return dp[n];
}
```

## 27、编辑距离

给你两个单词word1和word2，请你计算出将word1转换成word2所使用的最少操作数。

你可以对一个单词进行如下三种操作：
* 插入一个字符
* 删除一个字符
* 替换一个字符

示例1：输入：word1 = "horse", word2 = "ros" 输出3
解释：horse -> rorse(将'h'替换为'r') rorse->rose(删除'r') rose->ros(删除'e')

示例2：输入：word1 = "intention"，word2="execution" 输出：5
解释：intention->inention(删除't') inention->enention(将'i'替换为'e') enention->exention(将'n'替换为'x') exention->exection(将'n'替换为'c') exection->execution(插入'u')

* 思路

编辑距离是用动归来解决的经典题目

1. 确定dp数组以及下标的含义
dp[i][j]表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。

这里在强调以下：为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

2. 确定递推公式
在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：
```js
if (word1[i - 1] == word2[j - 1]) {
  不操作
}
if (word1[i - 1] != word2[j - 1]) {
  增、删、换
}
```
if (word1[i-1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j]就应该是dp[i-1][j-1]，即dp[i][j] = dp[i-1][j-1];

在整个动规的过程中，最为关键就是正确理解dp[i][j]的定义！
if (word1[i-1] != word2[j-1])，此时就需要编辑了
* 操作一：word1增加一个元素，使其word1[i-1]与word2[j-1]相同，那么就是以下标i-2为结尾的word1的最近编辑距离加上一个增加元素的操作。即dp[i][j] = dp[i-1][j] + 1;

* 操作二：word2添加一个元素，使其word1[i-1]与word2[j-1]相同，那么就是以下标i-1为结尾的word1与j-2为结尾的word2的最近编辑距离，加上一个增加元素的操作。即dp[i][j] = dp[i][j-1] + 1;
word2添加一个元素，相当于word1删除一个元素。

* 操作三：替换元素，word1替换word1[i-1]，使其与word2[j-1]相同，此时不用增加元素，那么以下标i-2为结尾的word1与j-2为结尾的word2的最近编辑距离加上一个替换元素的操作。即dp[i][j] = dp[i-1][j-1] + 1;
递归公式：
```js
if (word1[i-1] == word2[j - 1]) {
  dp[i][j] = dp[i-1][j-1];
} else {
  dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;
}
```

3. dp数组如何初始化
dp[i][j]表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]
dp[i][0]：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]

4. 确定遍历顺序
从如下四个递推公式：
* dp[i][j] = dp[i-1][j-1]
* dp[i][j] = dp[i-1][j-1] + 1
* dp[i][j] = dp[i][j-1] + 1
* dp[i][j] = dp[i-1][j] + 1

可以看出dp[i][j]是依赖左方，上方和左上方元素，在dp矩阵中一定是从左到右从上到下去遍历。

5. 举例推导dp数组

```js
const minDistance = (word1, word2) => {
  const m = word1.length;
  const n = word2.length;
  const dp = Array(m + 1).fill().map(item => Array(n + 1).fill(0));

  // 初始化
  for (let i = 1; i <= m; i++) {
    dp[i][0] = i;
  }

  for (let j = 1; j <= n; j++) {
    dp[0][j] = j;
  }

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      // 因为dp数组有效位从1开始
      // 所以当前遍历到的字符串的位置为i-1 | j -1
      if (word1.charAt(i-1) == word2.charAt(j-1)) {
        dp[i][j] = dp[i-1][j-1];
      } else {
        dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i][j-1]), dp[i-1][j]) + 1;
      }
    }
  }
  return dp[m][n];
}
```

## 28、组合

给定两个正数n和k，返回1...n中所有可能的k个数的组合。

示例：
输入：n = 4, k = 2
输出
[
  [2, 4],
  [3, 4],
  [2, 3],
  [1, 2],
  [1, 3],
  [1, 4],
]

* 思路
采用回溯法
回溯法解决的问题都可以抽象为树形结构(N叉树)，用树形结构来理解回溯就容易多了。
递归来做层叠嵌套，每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了。

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
可以发现n相当于树的宽度，k相当于树的深度。
每次搜索到了叶子节点，我们就找到了一个结果。

回溯法三部曲
* 递归函数的返回值以及参数
这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。
* 回溯函数终止条件
path数组大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。
* 单层搜索的过程
回溯法的搜索过程就是一个树形结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。

剪枝条件：如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么久没有必要搜索了。

```js
let result = [];
let path = [];
const combine = (n, k) => {
  result = [];
  combineHelper(n, k, 1);
  return result;
}

const combineHelper = (n, k, startIndex) => {
  if (path.length === k) {
    result.push([...path]);
    return;
  }
  for (let i = startIndex; i <= n - (k - path.length) + 1; ++i) {
    path.push(i);
    combineHelper(n, k, i + 1);
    path.pop();
  }
}
```

## 29、螺旋矩阵II

给定一个正整数n，生成一个包含1到n2所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例：

输入：3，输出：[[1,2,3],[8,9,4],[7,6,5]]

* 思路：双循环+四个边的方向判断
找到循环不变量原则

模拟顺时针画矩阵的过程：
* 填充上行从左到右；
* 填充右列从上到下；
* 填充下行从右到左；
* 填充左列从下到上；

采用每条边左闭右开的原则

```js
const generateMatrix = (n) => {
  // new Array(n).fill(new Array(n))
  // 使用fill -->填充的是同一个数组地址
  const res = Array.from({length: n}).map(() => new Array(n));
  let loop = n >> 1, i = 0, // 循环次数
  count = 1,
  startX = startY = 0; // 起始位置

  while (++i <= loop) {
    // 定义行列
    let row = startX, column = startY;
    // [startY, n - i)
    while(column < n - i) {
      res[row][column++] = count++;
    }

    // [startX, n - i)
    while(row < n - i) {
      res[row++][column] = count++;
    }

    // [n - i, startY)
    while(column > startY) {
      res[row][column--] = count++;
    }

    // [n - i, startX)
    while(row > startX) {
      res[row--][column] = count++;
    }
    startX = ++startY;
  }
  if (n & 1) {
    res[startX][startY] = count;
  }
  return res;
}
```

## 30、组合的优化

采用回溯法+剪枝优化
举一个例子，n=4, k=4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。在第二层for循环，从元素3开始的遍历都没有意义了。

可以剪枝的地方就是在递归中，每一层的for循环所选择的起始位置。
如果for循环选择的起始位置之后的元素个数，已经不足我们需要的元素个数了，那么就没有必要搜索了。

```js
const combine = (n, k) => {
  const res = [], path = [];
  backtracking(n, k, 1);
  return res;
  
  function backtracking(n, k, i) {
    const len = path.length;
    if (len === k) {
      res.push(Array.from(path));
      return;
    }
    for (let a = i; a <= n + len - k + 1; a++) {
      path.push(a);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 31、子集

给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例：输入nums = [1,2,3] 输出[[3], [1], [2], [1,2,3], [1,3], [2,3],[1,2], []]

* 思路：循环+回溯
子集问题是找树的所有节点。
取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！

遍历这个数的时候，把所有节点都记录下来，就是要求的子集集合。

* 回溯三部曲
1. 全局变量数组path为子集收集元素，二维数组result存放子集组合；
2. 递归终止条件：startIndex已经大于数组的长度了，就终止了，因为没有元素可取了。
3. 单层搜索逻辑：求取子集问题，不需要任何剪枝，因为子集就是要遍历整棵树。

```js
const subsets = (nums) => {
  let result = [];
  let path = [];
  backtracking(0);
  return result;

  function backtracking(startIndex) {
    result.push(path.slice());
    for(let i = startIndex; i < nums.length; i++) {
      path.push(nums[i]);
      backtracking(i + 1);
      path.pop();
    }
  }
}
```

## 31、子集II
给定一个可能包含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例：输入[1,2,2]，输出：[[2], [1], [1,2,2], [2,2], [1,2], []]

* 思路
采用回溯法，集合里有重复元素需要去重；去重可以采用树层去重或树枝去重。

```js
const subsetsWithDup = (nums) => {
  let result = [];
  let path = [];
  // 要去重先排序
  let sortNums = nums.sort((a, b) => {
    return a - b;
  })
  backtracking(0, sortNums);
  return result;
  function backtracking(startIndex, sortNums) {
    result.push(path.slice());
    if (startIndex > nums.length - 1) {
      return;
    }
    for (let i = startIndex; i < nums.length; i++) {
      if (i > startIndex && nums[i] === nums[i - 1]) {
        continue;
      }
      path.push(nums[i]);
      backtracking(i + 1, sortNums);
      path.pop();
    }
  }

}
```
