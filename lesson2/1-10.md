# 1-10 算法实战题集锦

## 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

* 思路：两层for循环查找，时间复杂度是O(n^2)。也可以使用map找差值减少一层循环。

```js
const twoSum = (nums, target) => {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;
  }
  return [];
}
```

## 2. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

* 思路：采用双指针法

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下表0的地方开始，同时定一个下表left 定义在i+1的位置上，定义下表right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下表就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：O(n^2)。

```js
const threeSum = (nums) => {
  const len = nums.length;
  if (len < 3) {
    return [];
  }
  nums.sort((a, b) => a - b); // 进行排序
  const res = [];
  for (let i = 0; i < len - 2; i++) {
    if (nums[i] > 0) {
      break;
    }
    // a去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let l = i + 1, r = len - 1;
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r];
      if (sum < 0) {
        l++;
        continue;
      }
      if (sum > 0) {
        r--;
        continue;
      }
      res.push([nums[i], nums[l], nums[r]])
      // b c 去重
      while(l < r && nums[l] === nums[++l]);
      while(l < r && nums[r] === nums[--r]);
    }
  }
  return res;
}
```

## 三、电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![2-1-10-1](/assets/2-1-10-1.png)

示例: 输入："23" 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

* 思路：回溯算法求组合问题，解决多层for循环带来的问题

需要解决三个问题：
1. 数字和字母如何映射；
 解法：可以使用map或者定义一个二维数组
2. 两个字母就两个for循环，三个字符就三个for循环，以此类推，代码根本写不出来；
 解法：使用回溯法来解决n个for循环的问题，例如：输入"23"抽象为树形结构，如图所示：
![2-1-10-2](/assets/2-1-10-2.png)
图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。

回溯三部曲：
* 确定回溯函数参数；需要一个字符串来收集叶子节点结果，然后用一个字符串数组result保存起来。
* 确定终止条件；终止条件就是如果index等于属于的数字个数
* 确定单层遍历逻辑；首先要取index指向的数字，并找到对应的字符集，然后for循环来处理这个字符集

3. 输入1*#按键等异常情况

```js
const letterCombinations = (digits) => {
  const k = digits.length;
  const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; // 使用map做数字和字母的映射
  if (!k) {
    return [];
  }
  if (k === 1) {
    return map[digits].split("");
  }

  const res = [], path = [];
  backtracking(digits, k, 0);
  return res;

  function backtracking(n, k, a) {
    if (path.length === k) {
      res.push(path.join(""));
      return;
    }
    for (const v of map[n[a]]) {
      path.push(v);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 四、四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

* 思路：双循环+双指针

四数之和，和三数之和一个解法，都是使用双指针法，基本解法就是在三数之和的基础之上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断nums[k] > target 就返回了，三数之和 可以通过 nums[i] > 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。

```js
const fourSum = (nums, target) => {
  const len = nums.length;
  if (len < 4) {
    return [];
  }
  nums.sort((a, b) => a - b);
  const res = [];
  for (let i = 0; i < len - 3; i++) {
    // 去重i
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    for (let j = i + 1; j < len - 2; j++) {
      // 去重j
      if (j > i + 1 && nums[j] === nums[j - 1]) {
        continue;
      }
      let l = j + 1, r = len - 1;
      while (l < r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        if (sum < target) {
          l++;
          continue;
        }
        if (sum > target) {
          r--;
          continue;
        }
        res.push([nums[i], nums[j], nums[l], nums[r]]);
        while (l < r && nums[l] === nums[++l]);
        while (l < r && nums[r] === nums[--r]);
      }
    }
  }
  return res;
}
```

## 五、删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 

示例 2：输入：head = [1], n = 1 输出：[] 示例 3：

示例 3：输入：head = [1,2], n = 1 输出：[1]

思路：
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

```js
const removeNthFromEnd = (head, n) => {
  let ret = new ListNode(0, head),
  slow = fast = ret;
  while(n--) {
    fast = fast.next; // fast移动n步
  }
  if (!fast) {
    return ret.next;
  }
  while(fast.next) {
    fast = fast.next;
    slow = slow.next;
  };
  slow.next = slow.next.next;
  return ret.next;
}
```

## 六、有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false

* 思路

括号匹配是使用栈解决的经典问题。
分析三种不匹配的情况：
1. 字符串里左方向的括号多余了，所以不匹配；
2. 括号没有多余，但是括号的类型没有匹配上；
3. 字符串里右方向的括号多余了，所以不匹配。

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

```js
const isValid = (s) => {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (c !== stack.pop()) {
          return false;
        }
    }
  }
  return stack.length === 0;
}
```

## 七、两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

* 思路：

建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

```js
const swapPairs = (head) => {
  let ret = new ListNode(0, head), temp = ret;
  while (temp.next && temp.next.next) {
    let cur = temp.next.next, pre = temp.next;
    pre.next = cur.next;
    cur.next = pre;
    temp.next = cur;
    temp = pre;
  }
  return ret.next;
}
```

## 八、 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

你不需要考虑数组中超出新长度后面的元素。

* 思路

要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。
双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

```js
const removeElement = (nums, val) => {
  let k = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != val) {
      nums[k++] = nums[i];
    }
  }
  return k;
}
```

## 九、实现strStr()
> 在一个串中查找是否出现过另一个串，这是KMP的看家本领。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。

KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。

```js
const strStr = (haystack, needle) => {
  if (needle.length === 0 || (haystack.length === 0 && needle.length === 0)) {
    return 0;
  }
  if (haystack.length === 0) {
    return -1;
  }
  return haystack.indexOf(needle);
}
```

## 10. 插入搜索位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1: 输入: [1,3,5,6], 5 输出: 2

示例 2: 输入: [1,3,5,6], 2 输出: 1

示例 3: 输入: [1,3,5,6], 7 输出: 4

示例 4: 输入: [1,3,5,6], 0 输出: 0

* 思路
 * 目标值在数组所有元素之前
 * 目标值等于数组中某一个元素
 * 目标值插入数组中的位置
 * 目标值在数组所有元素之后

* 解法：二分法
大家注意这道题目的前提是数组是有序数组，这也是使用二分查找的基础条件。
要在二分查找的过程中，保持不变量，这也就是循环不变量。

```js
const searchInsert = (nums, target) => {
  let l = 0, r = nums.length - 1, ans = nums.length;
  while (l <= r) {
    const mid = l + Math.floor((r - l) >> 1);
    if (target > nums[mid]) {
      l = mid + 1;
    } else {
      ans = mid;
      r = mid -1;
    }
  }
  return ans;
}
```

## 11. 解数独

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。

提示：
* 给定的数独序列只包含数字1-9和字符'.'
* 你可以假设给定的数独只有唯一解；
* 给定数独永远是9*9形式的。

### 思路 双循环+递归
棋盘搜索问题可以使用回溯法暴力搜搜，只不过这次我们要做的是二维递归。
本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深。

![2-1-10-3](/assets/2-1-10-3.png)

* 解法

回溯三部曲：

1. 递归函数以及参数
递归函数的返回值需要是bool类型，为什么呢？
因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值，

2. 递归终止条件
本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

3. 那么有没有永远填不满的情况呢？
一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！

```js
const solveSudoku = (board) => {
  function isValid(row, col, val, board) {
    let len = board.length;
    // 行不能重复
    for (let i = 0; i < len; i++) {
      if (board[row][i] === val) {
        return false;
      }
    }
    // 列不能重复
    for (let i = 0; i < len; i++) {
      if (board[i][col] === val) {
        return false;
      }
    }
    let startRow = Math.floor(row / 3) * 3;
    let startCol = Math.floor(col / 3) * 3;
    for (let i = startRow; i < startRow + 3; i++) {
      for (let j = startCol; j < startCol + 3; j++) {
        if (board[i][j] === val) {
          return false;
        }
      }
    }
    return true;
  }
  function backTracking() {
    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[0].length; j++) {
        if (board[i][j] !== '.') {
          continue;
        }
        for (let val = 1; val <= 9; val++) {
          if (isValid(i, j, `${val}`, board)) {
            board[i][j] = `${val}`
            if (backTracking()) {
              return true;
            }
            board[i][j] = `.`
          }
        }
        return false;
      }
    }
    return true;
  }
  backTracking(board);
  return board;
}
```

## 12、组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：
* 所有数字（包括target）都是正整数；
* 解集不能包含重复的组合。

示例1： 输入：candidates = [2, 3, 6, 7], target = 7, 所求解集为：[[7],[2,2,3]]

示例2：输入：candidates = [2, 3, 5], target=8,所求解集为：[[2, 2, 2, 2], [2, 3, 3], [3, 5]]

* 思路
本题搜索的过程抽象成树形结构如下：
![2-1-10-4](/assets/2-1-10-4.png)

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

* 回溯三部曲
1. 递归函数参数
这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）
2. 递归终止条件
从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。
sum等于target的时候，需要收集结果，代码如下：

```js
if (sum > target) {
  return;
}
if (sum == target) {
  result.push_back(path);
  return;
}
```
3. 单层搜索的逻辑
单层for循环依然是从startIndex开始，搜索candidates集合。
for循环剪枝代码优化：
```js
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

实现代码：

```js
const combinationSum = (candidates, target) => {
  const res = [], path = []; // path存放符合条件的结果
  candidates.sort(); // 排序
  backtracking(0, 0);
  return res;
  // 递归：深搜
  function backtracking(j, sum) {
    if (sum > target) {
      return; // 剪枝
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    // 广搜
    for (let i = j; i < candidates.length; i++) {
      const n = candidates[i];
      if (n > target - sum) {
        continue;
      }
      path.push(n);
      sum += n;
      backtracking(i, sum);
      path.pop();
      sum -= n;
    }
  }
}
```

## 13、组合总和II

给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。

candidates中的每个数字在每个组合中只能使用一次。

说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。
示例1：输入：candidates = [10, 1, 2, 7, 6, 1, 5]，target = 8，所求解集为：[[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]

示例2：输入：candidates = [2, 5, 2, 1, 2]，target = 5，所求解集为：[[1, 2, 2], [5]]

* 思路

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

所谓去重，其实就是使用过的元素不能重复选取。

组合问题可以抽象为树形结构，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。

我们要去重的是同一树层上的使用过，同一树枝上的都是一个组合里的元素，不用去重。
树层去重，需要对数组进行排序。

* 递归函数参数：需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。
* 递归终止条件：终止条件为sum > target和sum == target
* 单层搜索的逻辑
candidates[i] == candidates[i-1]并且used[i-1]==false，就说明前一个树枝，使用了candidates[i-1]，也就是说同一树层使用过candidates[i-1]。

```js
const combinationSum2 = (candidates, target) => {
  const res = [], path = [], len = candidates.length;
  candidates.sort();
  backtracking(0, 0);
  return res;

  function backtracking(sum, i) {
    if (sum > target) {
      return;
    }
    if (sum === target) {
      res.push(Array.from(path));
      return;
    }
    let f = -1;
    for (let j = i; j < len; j++) {
      const n = candidates[j];
      if (n > target - sum || n === f) {
        continue;
      }
      path.push(n);
      sum += n;
      f = n;
      backtracking(sum, j + 1);
      path.pop();
      sum -= n;
    }
  }
}
```

## 14、跳跃游戏II

给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例：输入：[2, 3, 1, 1, 4]输出：2
解释：跳到最后一个位置的最小跳跃数是2.从下标为0跳到下标为1的位置，跳1步，然后跳3步到达数组的最后一个位置。

说明：假设你总是可以到达数组的最后一个位置。

* 思路 贪心算法
要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！

贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。

```js
const jump = (nums) => {
  let curIndex = 0;
  let nextIndex = 0;
  let steps = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex);
    if (i === curIndex) {
      curIndex = nextIndex;
      steps++;
    }
  }
  return steps;
}
```

## 15、全排列

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：输入：[1,2,3]，输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

* 思路

循环+回溯法
for循环：横向遍历；
递归：纵向遍历；

回溯三部曲：
* 递归函数参数：首先排列是有序的，也就是说[1,2]和[2,1]是两个集合，这和之前分析的子集以及组合所不同的地方。可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用starIndex了。但排列问题需要一个used数组，标记已经选择的元素。

* 递归终止条件：可以看出叶子节点，就是收割结果的地方，当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

* 单层搜索的逻辑：因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用了，但是在[2,1]中还要再使用一次1。而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。

```js
const permute = (nums) => {
  const res = [], path = [];
  backtracking(nums, nums.length, []);
  return res;
  function backtracking(n, k, used) {
    if (path.length === k) {
      res.push(Array.from(path));
      return;
    }
    for (let i = 0; i < k; i++) {
      if (used[i]) {
        continue;
      }
      path.push(n[i]);
      used[i] = true; // 同枝
      backtracking(n, k, used);
      path.pop();
      used[i] = false;
    }
  }
}
```

## 16、全排列II

给定一个可包含重复数字的序列nums，按任意顺序返回所有不重复的全排列。

示例1：输入：nums = [1, 1, 2] 输出：[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
示例2：输入：nums[1, 2, 3]，输出：[[1,2,3], [1,3,2], [2,1,3], [3,1,2],[3,2,1]]

提示：
* 1<= nums.length <= 8
* -10 <= nums[i] <= 10

### 思路
采用回溯法，涉及去重，还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。

一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。

对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！

```js
const permuteUnique = (nums) => {
  const result = [], path = [];
  nums.sort();
  backtracking([]);
  return result;
  function backtracking(used) {
    if (path.length === nums.length) {
      result.push(path.slice());
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
        continue;
      }
      if (!used[i]) {
        used[i] = true;
        path.push(nums[i]);
        backtracking(used);
        path.pop();
        used[i] = false;
      }
    }
  }
}
```

## 17、N皇后

n皇后问题研究的是如何将n个皇后放置在n*n的棋盘上，并且使皇后彼此之间不能相互攻击。
给定一个整数n，返回所有不同的n皇后问题的解决方案。
每一种解法包含一个明确的n皇后问题的棋子放置方案，该方案中'Q'和'.'分别代表了皇后和空位。

示例：输入4，输出：[[".Q..", // 解法1"...Q", "Q...", "..Q."],
["..Q.", // 解法2 "Q...", "...Q",".Q.."]]
解释：4皇后问题存在两个不同的解法。

### 思路
n皇后问题是回溯算法解决的经典问题，回溯可解决组合、切割、子集、排列问题之后，对二维矩阵有一些挑战。

对皇后的约束条件：
1. 不能同行；
2. 不能同列；
3. 不能同斜线；（40度和135度角）

* 回溯三部曲
1. 递归函数参数：定义全局变量二维数组result来记录最终结果；参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。

2. 递归终止条件
当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

3. 单层搜索的逻辑
递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

```js
const solveQueens = (n) => {
  function isValid(row, col, chessBoard, n) {
    for (let i = 0; i < row; i++) {
      if (chessBoard[i][col] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (chessBoard[i][j] === 'Q') {
        return false;
      }
    }
    return true;
  }

  function transformChessBoard(chessBoard) {
    let chessBoardBack = [];
    chessBoard.forEach(row => {
      let rowStr = '';
      row.forEach(value => {
        rowStr += value
      })
      chessBoardBack.push(rowStr)
    })
    return chessBoardBack;
  }

  let result = [];
  function backtracking(row, chessBoard) {
    if (row === n) {
      result.push(transformChessBoard(chessBoard));
      return;
    }
    for (let col = 0; col < n; col++) {
      if (isValid(row, col, chessBoard, n)) {
        chessBoard[row][col] = 'Q';
        backtracking(row + 1, chessBoard);
        chessBoard[row][col] = '.';
      }
    }
  }
  let chessBoard = new Array(n).fill([]).map(() => new Array(n).fill('.'));
  backtracking(0, chessBoard);
  return result;
}
```

## 18、最大子序和

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例： 输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6，解释：连续子数组[4, -1, 2, 1]的和最大，为6

## 思路：看到连续和使用贪心
贪心解法
* 贪心贪的是哪里呢？
如果是-2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素"连续和"只会越来越小。
全局最优：选取最大“连续和”

* 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么久应该从nums[i+1]开始从0累积count了。因为已经变为负数的count，只会拖累总和。

* 暴力解法中的不断调整最大子序和区间的起始位置。

```js
const maxSubArray = (nums) => {
  let result = -Infinity;
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    count += nums[i];
    if (count > result) {
      result = count;
    }
    if (count < 0) {
      count = 0;
    }
  }
  return result;
}
```

## 19、最大子序和
给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例：输入：[-2, 1, -3, 4, -1, 2, 1, -5, 4] 输出：6
解释：连续子数组[4, -1, 2, 1]的和最大，为6.

### 思路
可以使用贪心算法，也可以使用动态规划

本次使用动态规划来解题：

* 动态规划五部曲：

1. 确定dp数组(dp table)以及下标的含义
dp[i]：包括下标i之前的最大连续子序列和为dp[i]。

2. 确定递推公式
dp[i]只有两个方向可以推出来：
* dp[i - 1] + nums[i]，即nums[i]加入当前连续子序列和
* nums[i]，即从头开始计算当前连续子序列和
一定是取最大的，所以dp[i] = max(dp[i-1] + nums[i], nums[i])

3. dp数组如何初始化
从递推公式可以看出来dp[i]是依赖于dp[i-1]的状态，dp[0]就是递推公式的基础。
dp[0]=nums[0]

4. 确定遍历顺序
递推公式中dp[i]依赖于dp[i-1]的状态，需要从前向后遍历。

5. 举例推导dp数组
注意最后的结果的是dp[i]对应最大的元素

```js
const maxSubArray = (nums) => {
  if (nums.length == 0) {
    return 0;
  }
  let res = nums[0];
  let dp = [];
  dp[0] = nums[0]; // 初始化都为0
  // 遍历方向从前往后
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); // 递推公式，dp[i]代表当前下标对应的最大值
    res = res > dp[i] ? res : dp[i];
  }
  return res;
}
```

## 20、跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

示例1：输入[2,3,1,1,4]，输出:true，解释：我们可以先跳1步，从位置0到达位置1，然后再从位置1跳3步到达最后一个位置。

示例2：输入[3,2,1,0,4]，输出：false，解释：无论怎样，你总会到达索引为3的位置。但该位置的足底啊跳跃长度是0，所以你永远不可能到达最后一个位置。

* 思路
贪心算法
核心问题：跳跃覆盖范围究竟可不可以覆盖到终点！每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。
每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。局部最优推出全局最优。

```js
const canJump = (nums) => {
  if (nums.length === 1) {
    return true;
  }
  let cover = 0;
  for (let i = 0; i <= cover; i++) {
    cover = Math.max(cover, nums[i] + i);
    if (cover >= nums.length - 1) {
      return true;
    }
  }
  return false;
}
```

## 21、合并区间

给出一个区间的集合，请合并所有重叠的区间。
示例1：输入intervals = [[1,3], [2,6], [8, 10], [15, 18]]，输出[[1,6],[8,10],[15,18]] 解释：区间[1,3]和[2,6]重叠，将它们合并为[1,6]

示例2：输入intervals=[[1,4],[4,5]] 输出:[[1,5]]，解释：区间[1,4]和[4,5]可被视为重叠区间。

提示：
* intervals[i][0] <= intervals[i][1]

### 思路 - 贪心
1. 首先需要先排序；
2. 排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。
intervals[i]的左边界在intervals[i-1]的左边界和右边界的范围内，那么一定有重复。

```js
const merge = (intervals) => {
  intervals.sort((a, b) => a[0] - b[0]);
  let prev = intervals[0];
  let result = [];
  for (let i = 0; i < intervals.length; i++) {
    let cur = intervals[i];
    if (cur[0] > prev[1]) {
      result.push(prev);
      prev = cur;
    } else {
      prev[1] = Math.max(cur[1], prev[1])
    }
  }
  result.push(prev);
  return result;
}
```

## 22、螺旋矩阵II

给定一个正整数n，生成一个包含1到n2的所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例：输入：3，输出：[[1,2,3],[8,9,4][7,6,5]]

* 思路：
循环不变量原则
模拟顺时针画矩阵的过程：
* 填充上行从左到右；
* 填充右列从上到下；
* 填充下行从右到左；
* 填充左列从下到上。
由外向内一圈一圈这么画下去。

按照左闭右开的原则，如下图：

![2-1-10-5](/assets/2-1-10-5.png)

```js
const generateMatrix = (n) => {
  //使用fill->填充的是同一个数组地址
  const res = Array.from({length: n}).map(() => new Array(n));
  let loop = n >> 1, i = 0, // 循环次数
  count = 1,
  startX = startY = 0; // 起始位置
  while (++i <= loop) {
    // 定义行列
    let row = startX, column = startY;
    // [startY, n - i)
    while (column < n - i) {
      res[row][column++] = count++;
    }
    // [startX, n - i)
    while (row < n - i) {
      res[row++][column] = count++;
    }
    // [n - i, startY)
    while(column > startY) {
      res[row][column--] = count++;
    }
    // [n - i, startX)
    while (row > startX) {
      res[row--][column] = count++;
    }
    startX = ++startY;
  }
  if (n & 1) {
    res[startX][startY] = count;
  }
  return res;
}
```

## 23、不同路径

一个机器人位于一个m*n的网格的左上角（起始点在下图中标记为"Start"）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为"Finish"）。
问总共有多少条不同的路径。

示例：输入m = 3, n = 7,输出：28
示例：输入m = 2, n = 3 输出：3 解释：从左上角开始，总共有3条路径可以到达右下角。
1. 向右->向右->向下
2. 向右-> 向下->向右
3. 向下->向右->向右

* 思路
动态规划：机器人从(0,0)位置出发，到(m-1,n-1)终点。

动态规划五部曲：
1. 确定dp数组以及下标的含义；
dp[i][j]：表示从(0, 0)出发，到(i,j)有dp[i][j]条不同的路径；
2. 确定递推公式
想要求dp[i][j]，只能有两个方向来推导出来，即dp[i-1][j]和dp[i][j-1]
此时在回顾一下dp[i-1][j]表示啥，是从(0,0)的位置到(i-1,j)有几条路径，dp[i][j-1]同理。
dp[i][j] = dp[i-1][j] + dp[i][j-1]，因为dp[i][j]只有这两个方向过来。
3. dp数组的初始化
如何初始化呢？首先dp[i][0]一定都是1，因为从(0,0)的位置到(i,0)的路径只有一条，那么dp[0][j]也同理。
所以初始化代码为：
```js
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```
4. 确定遍历顺序
这里要看一下递归公式dp[i][j] = dp[i-1][j] + dp[i][j-1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
这样就可以保证推导dp[i][j]的时候，dp[i-1][j]和dp[i][j-1]一定是有数值的。

5. 举例推导dp数组

```js
const uniquePaths = (m, n) => {
  const dp = Array(m).fill().map(item => Array(n)); // 初始化m*n空数组

  for (let i = 0; i < m; ++i) {
    dp[i][0] = 1;
  }

  for (let i = 0; i < n; ++i) {
    dp[0][i] = 1;
  }

  for (let i = 1; i < m; ++i) {
    for (let j = 1; j < n; ++j) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m-1][n-1];
}
```

## 24、不同路径II

一个机器人位于一个m*n网格的左上角（起始点在下图中标记为"Start"）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为"Finish"）。
现在考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？

示例1：网格中的障碍物和空位置分别用1和0来表示。
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2
解释：3*3网格的正中间有一个障碍物，从左上角到右下角一共有2条不同的路径：
1. 向右->向右->向下->向下;
2. 向下->向下->向右->向右;

* 思考
动态规划，有障碍的话，其实就是标记对应的dp table保持初始值(0)就可以了。

* 动态五部曲：

1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：表示从(0,0)出发，到(i,j)有dp[i][j]条不同的路径。

2. 确定递推公式
递推公式dp[i][j] = dp[i-1][j] + dp[i][j - 1];
这里要注意一点，因为有了障碍，(i,j)如果就是障碍的话应该就保持初始状态（初始状态为0）。
```js
if (obstacleGrid[i][j] == 0) {
  dp[i][j] = dp[i-1][j] + dp[i][j-1]; // 当(i,j)没有障碍的时候，再推导dp[i][j]
}
```

3. dp数组如何初始化
从(0,0)的位置到(i,0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理；
但如果(i,0)这条边有了障碍之后，障碍之后（包括障碍）都是走不动的位置，所以障碍之后的dp[i][0]应该还是初始值0。
注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理。

4. 确定遍历顺序
从递归公式dp[i][j] = dp[i-1][j] + dp[i][j-1]中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i-1][j]和dp[i][j-1]一定是有数值。

5. 举例推导dp数组

```js
const uniquePathsWithObstacles = (obstacleGrid) => {
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;
  const dp = Array(m).fill().map(item => Array(n).fill(0));

  for (let i = 0; i < m && obstacleGrid[i][0] === 0; ++i) {
    dp[i][0] = 1;
  }

  for (let i = 1; i < n && obstacleGrid[0][i] === 0; ++i) {
    dp[0][i] = 1;
  }

  for (let i = 1; i < m; ++i) {
    for (let j = 1; j < n; ++j) {
      dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
}
```

## 25、爬楼梯

假设你正在爬楼梯，需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定n是一个正整数。
示例1：输入2，输出2，解释：有两种方法可以爬到楼顶。
1. 1阶+1阶
2. 2阶

示例2：输入：3 输出3 解释：有三种方法可以爬到楼顶。
1. 1阶+1阶+1阶
2. 1阶+2阶
3. 2阶+1阶

* 思路：动态规划

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
那么第一层楼梯再跨两步就到第三层，第二层楼梯再跨一步就到第三层。
所以到第三层楼梯的状态可以由第二层楼梯和到第一层楼梯状态推导出来，可以使用动态规划。

动态规划5部曲
1. 确定dp数组以及下标的含义
dp[i]:爬到第i层楼梯，有dp[i]种方法；
2. 确定递推公式：
从dp[i]的定义可以看出，dp[i]可以有两个方向推出来。
首先dp[i-1]，上i-1层楼梯，有dp[i-1]种方法，那么再一步跳一个台阶就是dp[i]
dp[i-2]，上i-2层楼梯，有dp[i-2]种方法，那么再一步跳两个台阶就是dp[i]
所以：dp[i] = dp[i-1] + dp[i-2]
3. dp数组如何初始化
dp[i] = 1, dp[2] = 2, 然后从i=3开始递推，这样符合dp[i]的定义。
4. 确定遍历顺序
从递推公式dp[i] = dp[i-1] + dp[i-2]中可以看出，遍历顺序一定是从前向后遍历的。
5. 举例推导dp数组
举例当n为5的时候，dp[5]应该8

发现就是斐波那契

```js
const climbStairs = (n) => {
  // dp[i] 为第i阶楼梯有多少种方法爬到楼顶
  // dp[i] = dp[i-1] + dp[i-2]
  let dp = [1, 2];
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i -1] + dp[i - 2];
  }
  return dp[n - 1];
}
```

## 26、爬楼梯完全背包版本

假设你正在爬楼梯，需要n阶你才能到达楼顶。
一步1个台阶，两个台阶，三个台阶，...，直到m个台阶，你有多少种不同的方法可以爬到楼顶呢？

* 思路：动态规划 + 完全背包
这是一个完全背包问题了

动态规划5部曲：
1. 确定dp数组以及下标的含义；
dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。
2. 确定递推公式
装满背包的递推公式一般都是dp[i] += dp[i - nums[j]]，
本题，dp[i]有几种来源，dp[i-1], dp[i-2],dp[i-3]，那么递推公式为：dp[i] += dp[i - j]
3. dp数组如何初始化
既然递归公式是dp[i] += dp[i - j]，那么dp[0]一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。
4. 确定遍历顺序
这是背包里求排列问题，即：1、2步和2、1步都是上三个台阶，但是方法不同。
所以需要将target放在外循环，nums放在内循环。
5. 举例来推导dp数组
dp[4] = dp[3] + dp[2] + dp[1] = 7

```js
const climbStairs = (n) => {
  let dp = [1];
  let weight = [1, 2];
  for (let i = 0; i <= n; i++) {
    for (let j = 0; j < weight.length; j++) {
      if (i >= weight[j]) {
        dp[i] += dp[i - weight[j]];
      }
    }
  }
  return dp[n];
}
```

## 27、编辑距离

给你两个单词word1和word2，请你计算出将word1转换成word2所使用的最少操作数。

你可以对一个单词进行如下三种操作：
* 插入一个字符
* 删除一个字符
* 替换一个字符

示例1：输入：word1 = "horse", word2 = "ros" 输出3
解释：horse -> rorse(将'h'替换为'r') rorse->rose(删除'r') rose->ros(删除'e')

示例2：输入：word1 = "intention"，word2="execution" 输出：5
解释：intention->inention(删除't') inention->enention(将'i'替换为'e') enention->exention(将'n'替换为'x') exention->exection(将'n'替换为'c') exection->execution(插入'u')

* 思路

编辑距离是用动归来解决的经典题目

1. 确定dp数组以及下标的含义
dp[i][j]表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。

这里在强调以下：为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？

2. 确定递推公式
在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：
```js
if (word1[i - 1] == word2[j - 1]) {
  不操作
}
if (word1[i - 1] != word2[j - 1]) {
  增、删、换
}
```
if (word1[i-1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j]就应该是dp[i-1][j-1]，即dp[i][j] = dp[i-1][j-1];

在整个动规的过程中，最为关键就是正确理解dp[i][j]的定义！
if (word1[i-1] != word2[j-1])，此时就需要编辑了
* 操作一：word1增加一个元素，使其word1[i-1]与word2[j-1]相同，那么就是以下标i-2为结尾的word1的最近编辑距离加上一个增加元素的操作。即dp[i][j] = dp[i-1][j] + 1;

* 操作二：word2添加一个元素，使其word1[i-1]与word2[j-1]相同，那么就是以下标i-1为结尾的word1与j-2为结尾的word2的最近编辑距离，加上一个增加元素的操作。即dp[i][j] = dp[i][j-1] + 1;
word2添加一个元素，相当于word1删除一个元素。

* 操作三：替换元素，word1替换word1[i-1]，使其与word2[j-1]相同，此时不用增加元素，那么以下标i-2为结尾的word1与j-2为结尾的word2的最近编辑距离加上一个替换元素的操作。即dp[i][j] = dp[i-1][j-1] + 1;
递归公式：
```js
if (word1[i-1] == word2[j - 1]) {
  dp[i][j] = dp[i-1][j-1];
} else {
  dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;
}
```

3. dp数组如何初始化
dp[i][j]表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]
dp[i][0]：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]

4. 确定遍历顺序
从如下四个递推公式：
* dp[i][j] = dp[i-1][j-1]
* dp[i][j] = dp[i-1][j-1] + 1
* dp[i][j] = dp[i][j-1] + 1
* dp[i][j] = dp[i-1][j] + 1

可以看出dp[i][j]是依赖左方，上方和左上方元素，在dp矩阵中一定是从左到右从上到下去遍历。

5. 举例推导dp数组

```js
const minDistance = (word1, word2) => {
  const m = word1.length;
  const n = word2.length;
  const dp = Array(m + 1).fill().map(item => Array(n + 1).fill(0));

  // 初始化
  for (let i = 1; i <= m; i++) {
    dp[i][0] = i;
  }

  for (let j = 1; j <= n; j++) {
    dp[0][j] = j;
  }

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      // 因为dp数组有效位从1开始
      // 所以当前遍历到的字符串的位置为i-1 | j -1
      if (word1.charAt(i-1) == word2.charAt(j-1)) {
        dp[i][j] = dp[i-1][j-1];
      } else {
        dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i][j-1]), dp[i-1][j]) + 1;
      }
    }
  }
  return dp[m][n];
}
```

## 28、组合

给定两个正数n和k，返回1...n中所有可能的k个数的组合。

示例：
输入：n = 4, k = 2
输出
[
  [2, 4],
  [3, 4],
  [2, 3],
  [1, 2],
  [1, 3],
  [1, 4],
]

* 思路
采用回溯法
回溯法解决的问题都可以抽象为树形结构(N叉树)，用树形结构来理解回溯就容易多了。
递归来做层叠嵌套，每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了。

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
可以发现n相当于树的宽度，k相当于树的深度。
每次搜索到了叶子节点，我们就找到了一个结果。

回溯法三部曲
* 递归函数的返回值以及参数
这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。
* 回溯函数终止条件
path数组大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。
* 单层搜索的过程
回溯法的搜索过程就是一个树形结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。

剪枝条件：如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么久没有必要搜索了。

```js
let result = [];
let path = [];
const combine = (n, k) => {
  result = [];
  combineHelper(n, k, 1);
  return result;
}

const combineHelper = (n, k, startIndex) => {
  if (path.length === k) {
    result.push([...path]);
    return;
  }
  for (let i = startIndex; i <= n - (k - path.length) + 1; ++i) {
    path.push(i);
    combineHelper(n, k, i + 1);
    path.pop();
  }
}
```

## 29、螺旋矩阵II

给定一个正整数n，生成一个包含1到n2所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例：

输入：3，输出：[[1,2,3],[8,9,4],[7,6,5]]

* 思路：双循环+四个边的方向判断
找到循环不变量原则

模拟顺时针画矩阵的过程：
* 填充上行从左到右；
* 填充右列从上到下；
* 填充下行从右到左；
* 填充左列从下到上；

采用每条边左闭右开的原则

```js
const generateMatrix = (n) => {
  // new Array(n).fill(new Array(n))
  // 使用fill -->填充的是同一个数组地址
  const res = Array.from({length: n}).map(() => new Array(n));
  let loop = n >> 1, i = 0, // 循环次数
  count = 1,
  startX = startY = 0; // 起始位置

  while (++i <= loop) {
    // 定义行列
    let row = startX, column = startY;
    // [startY, n - i)
    while(column < n - i) {
      res[row][column++] = count++;
    }

    // [startX, n - i)
    while(row < n - i) {
      res[row++][column] = count++;
    }

    // [n - i, startY)
    while(column > startY) {
      res[row][column--] = count++;
    }

    // [n - i, startX)
    while(row > startX) {
      res[row--][column] = count++;
    }
    startX = ++startY;
  }
  if (n & 1) {
    res[startX][startY] = count;
  }
  return res;
}
```

## 30、组合的优化

采用回溯法+剪枝优化
举一个例子，n=4, k=4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。在第二层for循环，从元素3开始的遍历都没有意义了。

可以剪枝的地方就是在递归中，每一层的for循环所选择的起始位置。
如果for循环选择的起始位置之后的元素个数，已经不足我们需要的元素个数了，那么就没有必要搜索了。

```js
const combine = (n, k) => {
  const res = [], path = [];
  backtracking(n, k, 1);
  return res;
  
  function backtracking(n, k, i) {
    const len = path.length;
    if (len === k) {
      res.push(Array.from(path));
      return;
    }
    for (let a = i; a <= n + len - k + 1; a++) {
      path.push(a);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 31、子集

给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例：输入nums = [1,2,3] 输出[[3], [1], [2], [1,2,3], [1,3], [2,3],[1,2], []]

* 思路：循环+回溯
子集问题是找树的所有节点。
取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！

遍历这个数的时候，把所有节点都记录下来，就是要求的子集集合。

* 回溯三部曲
1. 全局变量数组path为子集收集元素，二维数组result存放子集组合；
2. 递归终止条件：startIndex已经大于数组的长度了，就终止了，因为没有元素可取了。
3. 单层搜索逻辑：求取子集问题，不需要任何剪枝，因为子集就是要遍历整棵树。

```js
const subsets = (nums) => {
  let result = [];
  let path = [];
  backtracking(0);
  return result;

  function backtracking(startIndex) {
    result.push(path.slice());
    for(let i = startIndex; i < nums.length; i++) {
      path.push(nums[i]);
      backtracking(i + 1);
      path.pop();
    }
  }
}
```

## 31、子集II
给定一个可能包含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例：输入[1,2,2]，输出：[[2], [1], [1,2,2], [2,2], [1,2], []]

* 思路
采用回溯法，集合里有重复元素需要去重；去重可以采用树层去重或树枝去重。

```js
const subsetsWithDup = (nums) => {
  let result = [];
  let path = [];
  // 要去重先排序
  let sortNums = nums.sort((a, b) => {
    return a - b;
  })
  backtracking(0, sortNums);
  return result;
  function backtracking(startIndex, sortNums) {
    result.push(path.slice());
    if (startIndex > nums.length - 1) {
      return;
    }
    for (let i = startIndex; i < nums.length; i++) {
      if (i > startIndex && nums[i] === nums[i - 1]) {
        continue;
      }
      path.push(nums[i]);
      backtracking(i + 1, sortNums);
      path.pop();
    }
  }

}
```

## 32、复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的IP地址格式。
有效的IP地址正好由四个整数（每个整数位于0到255之间组成，且不能含有前导0），整数之间用'.'分隔。

例如："0.1.2.201"和"192.168.1.1"是有效的IP地址，但是"0.011.255.245"、"192.168.1.312"和"192.168@1.1"是无效的IP地址。

示例1：输入：s = "25525511135" 输出：["255.255.11.135", "255.255.111.35"]

示例2：输入：s="0000" 输出:["0.0.0.0"]

示例3：输入：s="1111" 输出：["1.1.1.1"]

* 思路：
切割问题采用回溯搜索法把所有可能性搜出来，切割问题可以抽象为树形结构

回溯三部曲：
* 递归参数：startIndex一定是需要的，还需要一个变量pointNum记录添加逗点的数量；
* 递归终止条件：分割的段数作为终止条件。pointNum表示逗点数量，pointNum为3说明字符串分成了4段。
* 单层搜索的逻辑
循环[startIndex,i]这个区间就是截取的子串，需要判断这个子串是否合法。如果合法就在字符串后面加上符号.表示已经分割。

判断子串是否合法：
* 段位以0为开头的数字不合法；
* 段位里有非正整数字符不合法；
* 段位如果大于255了不合法。

```js
const restoreIpAddresses = (s) => {
  const res = [], path = [];
  backtracking(0);
  return res;

  function backtracking(i) {
    const len = path.length;
    if (len > 4) {
      return;
    }
    if (len === 4 && i === s.length) {
      res.push(path.join("."));
      return;
    }
    for (let j = i; j < s.length; j++) {
      const str = s.substr(i, j - i + 1);
      if (str.length > 3 || + str > 255) {
        break;
      }
      if (str.length > 1 && str[0] === "0") {
        break;
      }
      path.push(str);
      backtracking(j + 1);
      path.pop();
    }
  }
}
```

## 33. 不同的二叉搜索树
给定一个整数n，求以1...n为节点组成的二叉搜索树有多少种？

示例：

![2-1-10-6](/assets/2-1-10-6.png)

* 思路：动态规划
有2个元素的搜索树数量就是dp[2]
有1个元素的搜索树数量就是dp[1]
有0个元素的搜索树数量就是dp[0]
所以dp[3] = dp[2] * dp[0] + dp[1]*dp[1] + dp[0] * dp[2]

* 动态规划五部曲
1. 确定dp数组以及下标含义
dp[i]:1到i为节点组成的二叉搜索树的个数为dp[i]

2. 确定递推公式
dp[i] += dp[以i为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
j相当于是头结点的元素，从1遍历到i为止
所以递推公式：dp[i] += dp[j - 1] * dp[i -j]; j - 1为j为头结点左子树节点数量，i-j为以j为头结点右子树节点数量。

3. dp数组如何初始化
初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0].
dp[0] = 1;

4. 确定遍历顺序
从递推公式：dp[i] += dp[j-1] * dp[i -j]可以看出，节点数为i的状态是依靠i之前节点数的状态。那么遍历i里面每一个数作为头节点的状态，用j来遍历。

5. 举例推导dp数组
n=5，dp[i] = 42

```js
const numTrees = (n) => {
  let dp = Array(n+1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }
  return dp[n];
}
```

## 34、接雨水

给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例1：
![2-1-10-7](/assets/2-1-10-7.png)
输入：height = [0, 1, 0, 2, 1, 0, 1, ,3, 2, 1, 2, 1]
输出：6

解释：上面是由数组[0,1,0,2,1,0,1,3,2,1,2,1]表示的高度图，在这种情况下，可以接6个单位的雨水（蓝色部分表示雨水）。

示例2：
* 输入：height = [4,2,0,3,2,5]
* 输出：9

* 思路
接雨水问题再面试中还是常见题目的
解法有三种：
1. 双指针法
按照列来计算，宽度一定是1，把每一列的雨水高度求出来就可以了。可以看出每一列雨水的高度，取决于，该列左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。

2. 动态规划
递归公式：
即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);
从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

3. 单调栈

单调栈是按照行方向来计算雨水。
从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。

因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。

```js
const trap = (height) => {
  let sum = 0;
  let stack = []; // 这个栈是递减的栈
  let current = 0; // 声明一个索引和height的length比较，确保每个柱子都被遍历
  while (current < height.length) {
    // 如果栈中有值并且当前遍历的值大于栈顶的值，那进入循环， 将栈顶的值弹出，并计算弹出的值能接到的雨水
    while (stack.length > 0 && height[current] >= height[stack[stack.length - 1]]) {
      // 弹出栈顶的值
      let index = stack.pop();
      // 如果弹出栈顶的值后，栈为空，说明弹出值的前面没有比他更大的值，所以他接不到水
      if (stack.length == 0) {
        break;
      }
      // 计算弹出的值 与他左右两边第一个比他大的值，构成的距离
      let d = current - stack[stack.length - 1] - 1;
      // 计算左右两边第一个比他打的值的相对较小的值
      let h = Math.min(height[current], height[stack[stack.length - 1]]);
      // 计算能接到的水
      sum += d * (h - height[index]);
    }
    stack.push(current);
    current++;
  }
  return sum;
}
```

## 35、验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
二叉搜索树的特征：
* 节点的左子树只包含小于当前节点的数。
* 节点的右子树只包含大于当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

示例1：输出为true
```js
    2
   / \
  1   3
```

* 思路
中序遍历下，输出的二叉搜索树节点的数值是有序序列
有了这个特征，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。

```js
const isValidBST = (root) => {
  let arr = [];
  const buildArr = (root) => {
    if (root) {
      buildArr(root.left);
      arr.push(root.val);
      buildArr(root.right);
    }
  }
  buildArr(root);
  for (let i = 1; i < arr.length; ++i) {
    if (arr[i] <= arr[i - 1]) {
      return false;
    }
  }
  return true;
}
```

## 36、对称二叉树
给定一个二叉树，检查它是否是镜像对称的。
示例：二叉树[1,2,2,3,4,4,3]是对称的。

* 思路
判断对称二叉树要比较的是根节点的左子树与右子树是不是相互翻转，在递归遍历的过程中，也是要同时遍历两棵树。

比较两个子树的里侧和外侧的元素是否相等。
所以准确来说一棵树的遍历顺序是左右中，一个树遍历顺序是右左中。

递归三部曲
1. 确定递归函数的参数和返回值：比较的是两个树，参数是左子树节点和右子树节点
2. 确定终止条件：节点为空的情况判断，不为空的情况判断；
3. 确定单层递归的逻辑：比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。比较内测是否对称，传入左节点的右孩子，右节点的左孩子。如果左右都对称就返回true ，有一侧不对称就返回false 。

```js
const isSymmetric = (root) => {
  // 使用递归遍历左右子树，递归三部曲
  // 1. 确定递归的参数root.left root.right和返回值true false
  const compareNode = (left, right) => {
    // 2. 确定终止条件 空的情况
    if (left === null && right !== null || left !== null && right === null) {
      return false;
    } else if (left === null && right === null) {
      return true;
    } else if (left.val !== right.val) {
      return false;
    }
    // 3. 确定单层递归逻辑
    let outSide = compareNode(left.left, right.right);
    let inSide = compareNode(left.right, right.left);
    return outSide && inSide;
  }

  if (root === null) {
    return true;
  }

  return compareNode(root.left, root.right);
}
```

## 37、二叉树的层序遍历

给你一个二叉树，请你返回其按层序遍历得到的节点值（即逐层地，从左到右访问所有节点）。

示例：二叉树[3, 9, 20, null, null, 15, 7]

```js
     3
    / \
   9  20
      / \
     15  7
```
返回其层次遍历结果：

```js
[
  [3],
  [9, 20],
  [15, 7]
]
```

* 思路：

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。
需要借助一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑。
这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

```js
const levelOrder = (root) => {
  // 二叉树的层序遍历
  let res = [], queue = [];
  queue.push(root);
  if (root === null) {
    return res;
  }

  while (queue.length !== 0) {
    // 记录当前层级节点数
    let length = queue.length;
    // 存放每一层的节点
    let curLevel = [];

    for (let i = 0; i < length; i++) {
      let node = queue.shift();
      curLevel.push(node.val);
      // 存放当前层下一层的节点
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    // 把每一层的结果放到结果数组
    res.push(curLevel);
  }
  return res;
}
```

## 38、二叉树的最大深度

给定一个二叉树，找出其最大深度
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明：叶子节点是指没有子节点的节点。

示例：给定二叉树[3,9,20,null,null,15,7]

```js
     3
   /   \
  9    20
      /  \
     15   7
```

返回它的最大深度3.

* 思路
递归法：本题采用后序遍历（左右中），因为要通过递归函数的返回值做计算树的高度。

递归三部曲：
1、确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。
2、确定终止条件：如果为空节点的话，就返回0，表示高度为0.
3、确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值再+1（加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。

```js
const maxDepth = (root) => {
  // 使用递归的方法，递归三部曲
  //1. 确定递归函数的参数和返回值
  const getDepth = (node) => {
    // 2、确定终止条件
    if (node === null) {
      return 0;
    }

    // 3、确定单层逻辑
    let leftDepth = getDepth(node.left);
    let rightDepth = getDepth(node.right);
    let depth = 1 + Math.max(leftDepth, rightDepth);
    return depth;
  }

  return getDepth(root);
}
```

## 39、从中序与后序遍历序列构造二叉树

根据一棵树的中序遍历与后序遍历构造二叉树。
注意：你可以假设树中没有重复的元素。
例如，给出
中序遍历inorder = [9,3,15,20,7] 后续遍历postorder = [9,15,7,20,3]返回如下的二叉树：

```js
      3
    /   \
   9    20
       /  \
      15   7
```

* 思路
以后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。

一层一层切割，使用递归

1. 如果数组大小为0的话，说明是空节点；
2. 如果不为空，那么取后序数组最后一个元素作为节点元素。
3. 找到后序数组最后一个元素在中序数组的位置，作为切割点
4. 切割中序数组，切成中序左数组和中序右数组
5. 切割后序数组，切成后序左数组和后序右数组
6. 递归处理左区间和右区间。

```js
const buildTree = (inorder, postorder) => {
  if (!postorder.length) {
    return null;
  }
  let root = new TreeNode(postorder[postorder.length - 1]);
  let index = inorder.findIndex(number => number === root.val);

  root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
  root.right = buildTree(inorder.slice(index + 1, inorder.length), postorder.slice(index, postorder.length - 1));

  return root;
}
```

## 40、将有序数组转换为二叉搜索树

将一个按照圣墟排列的有序数组，转换为一颗高度平衡的二叉树。
一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1.

示例：给定有序数组：[-10, -3, 0, 5, 9]
一个可能的答案是：[0, -3, 9, -10, null, 5]它可以表示下面这个高度平衡二叉搜索树。

```js
     0
    /  \
   -3   9
  /    / 
 -10  5   
```

* 思路
本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。
分割点就是数组中间位置的节点。
本题可以采用递归来解
1. 确定递归函数返回值及其参数：删除二叉树节点或增加二叉树节点都是用递归函数的返回值来完成；
这里定义的是左闭右闭区间，在不断分割的过程中，也会坚持左闭右闭区间，需要找到循环不变量；
2. 确定递归终止条件
定义左闭右闭的区间，当left > right的时候，就是空节点了。
3. 确定单层递归的逻辑
首先取数组中间元素的位置，不难写出int mid = (left + right) / 2，考虑数值越界问题，可以这么写 int mid = left + ((right - left) / 2)；

迭代法可以通过三个队列来模拟，一个队列放遍历的节点，一个队列放左区间下标，一个队列放右区间下标。

```js
const sortedArrayToBST = (nums) => {
  const buildTree = (Arr, left, right) => {
    if (left > right) {
      return null;
    }
    let mid = Math.floor(left + (right - left) / 2);
    let root = new TreeNode(Arr[mid]);
    root.left = buildTree(Arr, left, mid - 1);
    root.right = buildTree(Arr, mid + 1, right);
    return root;
  }
  return buildTree(nums, 0, nums.length - 1);
}
```

## 41、平衡二叉树
给定一个二叉树，判断它是否是高度平衡二叉树
一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1.

示例1：
给定二叉树[3, 9, 20, null, null, 15, 7]

```js
     3
    /  \
   9   20
      /  \
     15   7
```

* 思路

采用递归法
要求比较高度，使用后序遍历（左右根）

递归三部曲：
1. 明确递归函数的参数和返回值（参数为传入的节点指针，返回值为根节点树的深度）；
2. 明确终止条件：递归的过程中依然是遇到空节点为终止，返回0，表示当前节点为根节点的树高度为0。
3. 明确单层递归的逻辑：左子树高度和右子树高度相差。如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉树了。

```js
const isBalanced = (root) => {
  // 还是用递归三部曲 + 后续遍历（左右中）当前左子树右子树高度相差大于1就返回-1
  // 1. 确定递归函数参数以及返回值
  const getDepth = (node) => {
    // 2. 确定递归函数终止条件
    if (node === null) {
      return 0;
    }
    // 3. 确定单层递归逻辑
    let leftDepth = getDepth(node.left); // 左子树高度
    if (leftDepth === -1) {
      return -1;
    }

    let rightDepth = getDepth(node.right); // 右子树高度
    if (rightDepth === -1) {
      return -1;
    }

    if (Math.abs(leftDepth - rightDepth) > 1) {
      return -1;
    } else {
      return 1 + Math.max(leftDepth, rightDepth);
    }
  }
  return getDepth(root) === -1 ? false : true;
}
```

## 42、二叉树的最小深度

给定一个二叉树，找出其最小深度
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。

示例：
给定二叉树[3,9,20,null,null,15,7]

```js
     3
    /  \
   9   20
      /  \
     15   7
```

返回它的最小深度2

* 思路：

最小深度是从根节点到最近叶子节点的最短路径上的节点数量，注意是叶子节点。

采用递归法
1. 确定递归函数的参数和返回值；参数为要传入的二叉树的根节点，返回的是int类型的深度；
2. 确定终止条件：终止条件也是遇到空节点返回0，表示当前节点的高度为0。
3. 确定单层递归的逻辑：遍历顺序为后续（左右中），可以看出，求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。

```js
const minDepth1 = (root) => {
  if (!root) {
    return 0;
  }

  // 到叶子节点， 返回1
  if (!root.left && !root.right) {
    return 1;
  }

  // 只有右节点时，递归右节点
  if (!root.left) {
    return 1 + minDepth(root.right);
  }

  // 只有左节点时，递归左节点
  if (!root.right) {
    return 1 + minDepth(root.left);
  }
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

## 42、路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明：叶子节点是指没有子节点的节点。

示例：给定如下二叉树，以及目标和sum = 22,

```js
         5
        /  \
       4    8
      /    /  \
     11   13   4
    /  \        \
   7    2        1
```

返回true，存在目标和22的跟几点到叶子节点的路径：5 -> 4 -> 11 -> 2。

* 思路：
使用递归法：可以使用深度优先遍历的方式来遍历二叉树
1. 确定递归函数的参数和返回类型；参数需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。
如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径就要及时返回。

2. 确定终止条件：采用计数器count初始为目标和，然后每次减去遍历路径节点上的数值，如果遍历到了叶子节点，count==0，同时到了叶子节点的话，说明找到了目标和。

3. 确定单层递归的逻辑：因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归。

```js
const pathSum = (root, targetSum) => {
  // 递归方法
  let resPath = [], curPath = [];
  // 1. 确定递归函数参数
  const travelTree = (node, count) => {
    curPath.push(node.val);
    count -= node.val;

    if (node.left === null && node.right === null && count === 0) {
      resPath.push([...curPath]);
    }
    node.left && travelTree(node.left, count);
    node.right && travelTree(node.right, count);

    let cur = curPath.pop();
    count -= cur;
  }
  if (root === null) {
    return resPath;
  }

  travelTree(root, targetSum);
  return resPath;
}
```

## 43、不同的子序列

给定一个字符串s和一个字符串t，计算在s的子序列中t出现的个数。
字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE”是"ABCDE"的一个子序列，而"AEC"不是）

题目数据保证答案符合32位带符号整数范围。

示例2：
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示，有3种可以从s中得到"rabbit"的方案。
（上箭头符号^表示选取的字母）
rabb b it

ra b bbit

rab b bit

* 思路
采用动态规划
1. 确定dp数组以及下标的含义
dp[i][j]:以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。

2. 确定递推公式
这一类问题，基本是要分析两种情况
* s[i-1]与t[j-1]相等
递推公式：dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
* s[i-1]与t[j-1]不相等
递推公式：dp[i][j] = dp[i-1][j]

3. dp数组如何初始化
从递推公式dp[i][j] = dp[i-1][j-1] + dp[i-1][j];和dp[i][j] = dp[i-1][j]; 中可以看出dp[i][0]和dp[0][j]是一定要初始化的。
dp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。

4. 确定遍历顺序
从递推公式dp[i][j] = dp[i-1][j-1] + dp[i-1][j];和dp[i][j]=dp[i-1][j]；中可以看出dp[i][j]都是根据左上方和正上方推出来的。
所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。

5. 举例推导dp数组
以s："baegg"，t: "bag"为例，推导dp数组状态如下：

```js
const numDistinct = (s, t) => {
  let dp = Array.from(Array(s.length + 1), () => Array(t.length + 1).fill(0));

  for (let i = 0; i <= s.length; i++) {
    dp[i][0] = 1;
  }

  for (let i = 1; i <= s.length; i++) {
    for (let j = 1; j <= t.length; j++) {
      if (s[i-1] === t[j-1]) {
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
      } else {
        dp[i][j] = dp[i-1][j]
      }
    }
  }
  return dp[s.length][t.length];
}
```

## 44、买卖股票的最佳时机

给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子，卖出该股票。设计一个算法计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0.

示例1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第2天（股票价格=1）的时候买入，在第5天（股票价格=6）的时候卖出，最大利润6-1=5.注意利润不能是7-1=6，因为卖出价格需要大于买入价格；同时，你不能再买入前卖出股票。

* 思路
贪心算法：股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。

动态规划：
1. 确定dp数组以及下标的含义：dp[i][0]表示第i天持有股票所得最多现金，本题中只能买卖一次，持有股票之后哪还有现金呢？
其实一开始现金是0，那么假如第i天买入股票现金就是-prices[i]，这是一个负数。
dp[i][1]表示第i天不持有股票所得最多现金

2. 确定递推公式：
 * 如果第i天持有股票：dp[i][0] = max(dp[i-1][0], -prices[i]);
 * 如果第i天不持有股票：dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]);

3. dp数组如何初始化
由递推公式dp[i][0] = max(dp[i-1][0], -prices[i]);和dp[i][1] = max(dp[i-1][1], prices[i]+dp[i-1][0]);可以看出其基础都是要从dp[0][0]和dp[0][1]推导出来。

4. 确定遍历顺序
从递推公式看出dp[i]都是有dp[i-1]推导出来的，那么一定是从前向后遍历。

5. 举例推导dp数组
dp[5][1]是最终结果。

```js
const maxProfit = (prices) => {
  let minPrice = Number.MAX_VALUE;
  let maxProfit = 0;

  for (let i = 0; i < prices.length; i++) {
    minPrice = Math.min(prices[i], minPrice); // 第i天之前的最低股价
    maxProfit = Math.max(maxProfit, prices[i] - minPrice); // 第i天时股票可以获取的最大利润
  }
  return maxProfit;
}
```

## 45、买卖股票的最佳时机II

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

* 思路：
贪心算法
假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。
相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。
此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！

那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

局部最优：收集每天的正利润，全局最优：求得最大利润。

```js
const maxProfit = (prices) => {
  let result = 0;
  for (let i = 1; i < prices.length; i++) {
    result += Math.max(prices[i] - prices[i - 1], 0);
  }
  return result;
}
```

## 46、买卖股票的最佳时机III

给定一个数组，它的第i个元素是一支给定的股票在第i天的价格。
设计一个算法来计算你所能获取的最大利润，你最多可以完成两笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1：输入：prices = [3,3,5,0,0,3,1,4]输出：6 解释：在第4天（股票价格=0）的时候买入，在第6天（股票价格=3）的时候卖出，这笔交易所能获得利润=3-0=3，随后，在第7天（股票价格=1）的时候买入，在第8天（股票价格=4）的时候卖出，这笔交易所能获得利润=4-1=3。

* 思路：动态规划
关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。
动态规划五部曲：
1. 确定dp数组以及下标的含义
一天一共就有5个状态：
0：没有操作
1：第一次买入
2：第二次卖入
3：第二次买入
4：第二次卖出

dp[i][j]中i表示第i天，j为[0-4]五个状态，dp[i][j]表示第i天状态j所剩最大现金。

2. 确定递推公式
需要注意：dp[i][1]，表示的是第i天，买入股票的装填，并不是说一定要第i天买入股票，这是很多人容易陷入的误区。

达到dp[i][1]状态，有两个具体操作：
* 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i-1][1]

dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);

3. dp数组如何初始化
第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;
第0天做第一次买入的操作，dp[0][1] = -prices[0];
第0天做第一次卖出的操作，dp[0][2] = 0;
第0天做第二次买入操作，dp[0][3] = -prices[0];
第0天第二次卖出初始化, dp[0][4] = 0;

4. 确定遍历顺序
从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i-1]的数值。

5.举例推导dp数组
最终最大利润是dp[4][4]

```js
const maxProfit = (prices) => {
  let len = prices.length;
  // 边界判断，题目中length >= 1, 所以可省去
  if (len === 0) {
    return 0;
  }

  /**
   * 定义5种状态：
   * 0: 没有操作，1： 第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出
   */
  const dp = Array(len).fill().map(item => Array(5).fill(0));

  dp[0][1] = -prices[0];
  // 初始化第二次买入的状态是确保，最后结果是最多两次买卖的最大利润
  dp[0][3] = -prices[0];

  for (let i = 1; i < len; i++) {
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    dp[i][2] = Math.max(dp[i-1][2], dp[i][1] + prices[i]);
    dp[i][3] = Math.max(dp[i-1][3], dp[i][2] - prices[i]);
    dp[i][4] = Math.max(dp[i-1][4], dp[i][3] + prices[i]);
  }
  return dp[len-1][4];
}
```

## 47、分割回文串

给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。
返回s所有可能的分割方案。

示例：输入"aab"，输出[["aa", "b"], ["a", "a", "b"]]

* 思路：采用回溯
本题涉及到两个关键问题：
1. 切割问题，有不同的切割方式；
2. 判断回文

切割问题：采用回溯
* 递归函数参数
全局变量数组path存放切割后回文的子串，二维数组result存放结果集，还需要一个startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。

* 递归函数终止条件
切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。

* 单层搜索的逻辑
定义了起始位置startIndex，那么[startIndex, i]就是要截取的子串。

注意切割过的位置，不能重复切割，所以backtracking(s, i+1)，传入下一层的起始位置为i+1。

判断回文子串
使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。

```js
const isPalindrome = (s, l, r) => {
  for (let i = l, j = r; i < j; i++, j--) {
    if (s[i] !== s[j]) {
      return false;
    }
  }
  return true;
}

const partition = (s) => {
  const res = [], path = [], len = s.length;
  backtracking(0);
  return res;

  function backtracking(i) {
    if (i >= len) {
      res.push(Array.from(path));
      return;
    }
    for (let j = i; j < len; j++) {
      if (!isPalindrome(s, i, j)) {
        continue;
      }
      path.push(s.substr(i, j - i + 1));
      backtracking(j + 1);
      path.pop();
    }
  }
}
```

## 48、加油站

在一条环路上有N个加油站，其中第i个加油站有汽油gas[i]升。
你有一辆油箱容量无限的汽车，从第i个加油站开往第i+1个加油站需要消耗汽油cos[i]升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回-1.

说明：
* 如果题目有解，该答案即为唯一答案；
* 输入数组均为非空数组，且长度相同；
* 输入数组中的元素均为非负数。

示例1：输入：gas = [1, 2, 3, 4, 5] cost = [3, 4, 5, 1, 2]

输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。

* 思路：贪心算法
首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。
每个加油站的剩余量rest[i]为gas[i]-cost[i]。
i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0,1]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。

局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置。

```js
const canCompleteCircuit = (gas, cost) => {
  const gasLen = gas.length;
  let start = 0;
  let curSum = 0;
  let totalSum = 0;

  for (let i = 0; i < gasLen; i++) {
    curSum += gas[i] - cost[i];
    totalSum += gas[i] - cost[i];
    if (curSum < 0) {
      curSum = 0;
      start = i + 1
    }
  }
  if (totalSum < 0) {
    return -1;
  }
  return start;
}
```

## 49、分发糖果

老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
* 每个孩子至少分配到1个糖果；
* 相邻的孩子中，评分高的孩子必须获得更多的糖果。

示例1：输入：[1,0,2]输出：5 解释：你可以分别给这三个孩子分发2、1、2颗糖果。
示例2：输入：[1,2,2]输出：4 解释：你可以分别给这三个孩子分发1、2、1颗糖果。第三个孩子只得到1颗糖果，这已满足上述两个条件。

### 思路：贪心算法
先确定右边评分大于左边的情况（从前向后遍历），此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果，局部最优可以推出全局最优。

如果ratings[i] > ratings[i-1]，那么[i]的糖一定要比[i-1]的糖多一个，所以贪心：candyVec[i] = candyVec[i-1] + 1

确定左孩子大于右孩子的情况一定要从后向前遍历！candyVec[i]只有取最大的才能既保持对左边candyVec[i-1]的糖果多，也比右边candyVec[i+1]的糖果多。

采用两次贪心的策略：
* 一次是从左到右的遍历，只比较右边孩子评分比左边大的情况；
* 一次是从右到左的遍历，只比较左边孩子评分比右边大的情况。

这样从局部最优推出了全局最优，即：相邻的孩子中，评分搞的孩子获得更多的糖果。

```js
const candy = (ratings) => {
  let candys = new Array(ratings.length).fill(1);

  for (let i = 1; i < ratings.length; i++) {
    if (ratings[i] > ratings[i - 1]) {
      candys[i] = candys[i-1] + 1;
    }
  }

  for (let i = ratings.length - 2; i >= 0; i--) {
    if (ratings[i] > ratings[i+1]) {
      candys[i] = Math.max(candys[i], candys[i+1] + 1)
    }
  }

  let count = candys.reduce((a, b) => {
    return a + b;
  })

  return count;
}
```

## 50、单词拆分

给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆分为一个或多个在字典中出现的单词。

拆分时可以重复使用字典的单词。
你可以假设字典中没有重复的单词。

示例1：输入s="leetcode", wordDict = ["leet", "code"] 输出true，解释返回true，因为"leetcode"可以被拆分成"leet code"。

示例2：输入s="appleopenapple", wordDict = ["apple", "pen"] 输出true，解释：返回true，因为"applepenapple"可以被拆分成"apple pen apple"。注意你可以重复使用字典中的单词。

* 思路：背包思路
单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。
拆分时可以重复使用字典中的单词，说明就是一个完全背包！

动态规划五部曲：
1. 确定dp数组以及下标的含义
dp[i]：字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。
2. 确定递推公式
如果确定dp[j]是true，且[j,i]这个区间的子串出现在字典里，那么dp[i]一定是true。（j<i)
所以递推公式是if([j,i]这个区间的子串出现在字典里&&dp[j]是true) 那么dp[i]=true。
3. dp数组如何初始化
从递归公式中可以看出，dp[i]的状态依靠dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都是false。
4. 确定遍历顺序
拆分为一个或多个在字典中出现的单词，所以这是完全背包。
* 如果求组合数：外层for循环遍历物品，内层for遍历背包；
* 如果求排列数：外层遍历背包，内层for循环遍历物品。
因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。

```js
const wordBreak = (s, wordDict) => {
  let dp = Array(s.length + 1).fill(false);
  dp[0] = true;
  // s=>背包，wordDict=>商品
  for (let i = 0; i <= s.length; i++) {
    for (let j = 0; j < wordDict.length; j++) {
      if (i >= wordDict[j].length) {
        if (s.slice(i - wordDict[j].length, i) === wordDict[j] && dp[i - wordDict[j].length]) {
          dp[i] = true;
        }
      }
    }
  }
  return dp[s.length];
}
```

## 51、环形链表II

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。
为了表示给定链表中的环，使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。
说明：不允许修改给定的链表。

示例1：
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例2：
输入: head = [1, 2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

* 思路：考察对链表的操作，而且还需要一些数学运算。
 * 判断链表是否环
 使用快慢指针法，分别定义fast和slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果fast和slow指针在途中相遇，说明这个链表有环。

 * 如果有环，如何找到这个环的入口
 假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![2-1-10-8](/assets/2-1-10-8.png)

那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数： x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A

从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。

```js
// 先判断是否是环形链表
const detectCycle = (head) => {
  if (!head || !head.next) {
    return null;
  }

  let slow = head.next, fast = head.next.next;
  while (fast && fast.next && fast !== slow) {
    slow = slow.next;
    fast = fast.next.next;
  }
  if (!fast || !fast.next) {
    return null;
  }

  slow = head;
  while (fast !== slow) {
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
}
```

## 52、逆波兰表达式求值

有效的运算符包括+,-,*,/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：
整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为0的情况。

示例1：
* 输入：["2", "1", "+", "3", " * "]
* 输出：9
* 解释：该算式转化为常见的中缀算术表达式为：((2+1)*3) = 9

逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如(1+2) * (3 + 4)
该算式的逆波兰表达式写法为((12+)(34+)*)。

逆波兰表达式主要有以下两个优点：
* 去掉括号后表达式无歧义，上式即便写成12+34+*也可以依据次序计算出正确结果。
* 适合用栈操作运算，遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

### 思路：使用栈解决

逆波兰表达式相当于是二叉树中的后序遍历。大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

```js
const evalRPN = (tokens) => {
  const s = new Map([
    ["+", (a, b) => a * 1 + b * 1],
    ["-", (a, b) => b - a],
    ["*", (a, b) => b * a],
    ["/", (a, b) => (b / a) | 0]
  ]);

  const stack = [];
  for (const i of tokens) {
    if (!s.has(i)) {
      stack.push(i);
      continue;
    }
    stack.push(s.get(i)(stack.pop(), stack.pop()));
  }
  return stack.pop();
}
```

## 53、翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例1：输入："the sky is blue"  输出："blue is sky the"

* 思路
1. 移除多余空格；
2. 将整个字符串反转；
3. 将每个单词反转。

使用双指针来移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。

```js
let reverseWords = (s) => {
  let r = s.length - 1, l = r, res = "";
  while (l >= 0) {
    // 先找到单词的尾部
    while (s[r] === " ") {
      r--;
    }
    l = r;

    // 给上次单词加空格，排除第一次
    if (l >= 0 && res) {
      res += " ";
    }

    // 再找到单词的头部
    while (s[l] && s[l] !== " ") {
      l--;
    }

    // 遍历单词并添加
    for (let i = l + 1, j = r; i <= j; i++) {
      res += s[i];
    }

    // 跳到下一个单词
    r = l;
  }
  return res; 
}
```

## 54、买卖股票的最佳时机IV

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1：输入k=2，prices = [2, 4, 1] 输出：2 解释：在第1天（股票价格=2）的时候买入，在第2天（股票价格=4）的时候卖出，这笔交易所能获得利润4-2=2.

* 思路
采用动态规划实现
1. 确定dp数组以及下标的含义
使用二维数组dp[i][j]：第i天的状态为j，所剩下的最大现金是dp[i][j]。
j的状态表示为：
* 0 表示不操作
* 1 第一次买入
* 2 第一次卖出
* 3 第二次买入
* 4 第二次卖出
* ......

除了0之外，偶数就是卖出，奇数就是买入。题目要求是至多有K笔交易，那么j的范围就定义为2*k+1就可以了。

2. 确定递推公式
强调以下，dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票
达到dp[i][j]状态，有两个具体操作：
* 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i-1][1]

选最大的，所以dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][0]);

同理dp[i][2]也有两个操作：
* 操作一：第i天卖出股票了，那么dp[i][2] = dp[i-1][1] + prices[i];
* 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i-1][2]

所以dp[i][2] = max(dp[i-1][i] + prices[i], dp[i][2])
这里要类比j为奇数是买，偶数是卖的状态。

3. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;
第0天做第一次买入的操作，dp[0][1] = -prices[0];
首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0.
从递推公式可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。
dp[0][2] = 0;

```js
for (int j = 1; j < 2 * k; j += 2) {
  dp[0][j] = -prices[0];
}
```

在初始化的地方同样要类比j为偶数是卖、奇数是买的状态。

4. 确定遍历顺序
从递归公式其实已经可以看出，一定要从前向后遍历，因为dp[i]，依靠dp[i-1]的数值。

5. 举例推导dp数组
以输入[1,2,3,4,5]，k=2为例。最后一次卖出，一定是利润最大的，dp[prices.size()-1][2 * k]即红色部分就是最后求解。

```js
const maxProfit = (k, prices) => {
  if (prices == null || prices.length < 2 || k == 0) {
    return 0;
  }
  let dp = Array.from(Array(prices.length), () => Array(2*k+1).fill(0));
  for (let j = 1; j < 2 * k; j+= 2) {
    dp[0][j] = 0 - prices[0]; // 偶数卖出
  }

  for (let i = 1; i < prices.length; i++) {
    for (let j = 0; j < 2 * k; j += 2) {
      dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] - prices[i]);
      dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]);
    }
  }
  return dp[prices.length - 1][2 * k];
}
```

## 55、打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

示例1：输入：[1, 2, 3, 1]，输出4，解释：偷窃1号房屋（金额=1），然后偷窃3号房屋（金额=3）。偷窃到的最高金额 = 1 + 3 = 4.

* 思路
打家劫舍是动态规划的经典问题
1. 确定dp数组以及下标含义
dp[i]:考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。

2. 确定递推公式
决定dp[i]的因素就是第i房间偷还是不偷。
如果偷第i房间，那么dp[i] = dp[i-2] + nums[i]，即：第i-1房一定是不考虑的，找出下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2]加上第i房间偷到的钱。
如果不偷第i房间，那么dp[i] = dp[i-1]，即考虑i-1房
然后dp[i]取最大值，即dp[i] = max(dp[i-2] + nums[i], dp[i-1]);

3. dp数组如何初始化
从递推公式dp[i] = max(dp[i-2] + nums[i], dp[i-1]); 可以看出，递推公式的基础就是dp[0]和dp[1]
从dp[i]的定义上来讲，dp[0]一定是nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

4. 确定遍历顺序
dp[i]是根据dp[i-2]和dp[i-1]推导出来的，那么一定是从前到后遍历！

5. 举例推导dp数组

```js
const rob = (nums) => {
  if (nums == null || nums.length == 0) {
    return 0;
  }
  if (nums.length == 1) {
    return nums[0];
  }
  let dp = Array.from(nums.length).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(dp[0], nums[1]);

  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
  }

  return dp[nums.length - 1];
}
```
