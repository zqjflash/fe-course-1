# 1-10 算法实战题集锦

## 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

* 思路：两层for循环查找，时间复杂度是O(n^2)。也可以使用map找差值减少一层循环。

```js
const twoSum = (nums, target) => {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;
  }
  return [];
}
```

## 2. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

* 思路：采用双指针法

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下表0的地方开始，同时定一个下表left 定义在i+1的位置上，定义下表right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i] b = nums[left] c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下表就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

时间复杂度：O(n^2)。

```js
const threeSum = (nums) => {
  const len = nums.length;
  if (len < 3) {
    return [];
  }
  nums.sort((a, b) => a - b); // 进行排序
  const res = [];
  for (let i = 0; i < len - 2; i++) {
    if (nums[i] > 0) {
      break;
    }
    // a去重
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let l = i + 1, r = len - 1;
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r];
      if (sum < 0) {
        l++;
        continue;
      }
      if (sum > 0) {
        r--;
        continue;
      }
      res.push([nums[i], nums[l], nums[r]])
      // b c 去重
      while(l < r && nums[l] === nums[++l]);
      while(l < r && nums[r] === nums[--r]);
    }
  }
  return res;
}
```

## 三、电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![2-1-10-1](/assets/2-1-10-1.png)

示例: 输入："23" 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

* 思路：回溯算法求组合问题，解决多层for循环带来的问题

需要解决三个问题：
1. 数字和字母如何映射；
 解法：可以使用map或者定义一个二维数组
2. 两个字母就两个for循环，三个字符就三个for循环，以此类推，代码根本写不出来；
 解法：使用回溯法来解决n个for循环的问题，例如：输入"23"抽象为树形结构，如图所示：
![2-1-10-2](/assets/2-1-10-2.png)
图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。

回溯三部曲：
* 确定回溯函数参数；需要一个字符串来收集叶子节点结果，然后用一个字符串数组result保存起来。
* 确定终止条件；终止条件就是如果index等于属于的数字个数
* 确定单层遍历逻辑；首先要取index指向的数字，并找到对应的字符集，然后for循环来处理这个字符集

3. 输入1*#按键等异常情况

```js
const letterCombinations = (digits) => {
  const k = digits.length;
  const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; // 使用map做数字和字母的映射
  if (!k) {
    return [];
  }
  if (k === 1) {
    return map[digits].split("");
  }

  const res = [], path = [];
  backtracking(digits, k, 0);
  return res;

  function backtracking(n, k, a) {
    if (path.length === k) {
      res.push(path.join(""));
      return;
    }
    for (const v of map[n[a]]) {
      path.push(v);
      backtracking(n, k, a + 1);
      path.pop();
    }
  }
}
```

## 四、四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

* 思路：双循环+双指针

四数之和，和三数之和一个解法，都是使用双指针法，基本解法就是在三数之和的基础之上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断nums[k] > target 就返回了，三数之和 可以通过 nums[i] > 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下表作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。

```js
const fourSum = (nums, target) => {
  const len = nums.length;
  if (len < 4) {
    return [];
  }
  nums.sort((a, b) => a - b);
  const res = [];
  for (let i = 0; i < len - 3; i++) {
    // 去重i
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    for (let j = i + 1; j < len - 2; j++) {
      // 去重j
      if (j > i + 1 && nums[j] === nums[j - 1]) {
        continue;
      }
      let l = j + 1, r = len - 1;
      while (l < r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        if (sum < target) {
          l++;
          continue;
        }
        if (sum > target) {
          r--;
          continue;
        }
        res.push([nums[i], nums[j], nums[l], nums[r]]);
        while (l < r && nums[l] === nums[++l]);
        while (l < r && nums[r] === nums[--r]);
      }
    }
  }
  return res;
}
```

## 五、删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 

示例 2：输入：head = [1], n = 1 输出：[] 示例 3：

示例 3：输入：head = [1,2], n = 1 输出：[1]

思路：
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

```js
const removeNthFromEnd = (head, n) => {
  let ret = new ListNode(0, head),
  slow = fast = ret;
  while(n--) {
    fast = fast.next; // fast移动n步
  }
  if (!fast) {
    return ret.next;
  }
  while(fast.next) {
    fast = fast.next;
    slow = slow.next;
  };
  slow.next = slow.next.next;
  return ret.next;
}
```

## 六、有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false

* 思路

括号匹配是使用栈解决的经典问题。
分析三种不匹配的情况：
1. 字符串里左方向的括号多余了，所以不匹配；
2. 括号没有多余，但是括号的类型没有匹配上；
3. 字符串里右方向的括号多余了，所以不匹配。

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

```js
const isValid = (s) => {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (c !== stack.pop()) {
          return false;
        }
    }
  }
  return stack.length === 0;
}
```